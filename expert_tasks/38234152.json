{
    "task": "How can I make this rxjava zip to run in parallel?",
    "description": "I have a sleep method for simulating a long running process.\nThen I have a method returns an Observable containing a list of 2 strings that is given in the parameters.\nIt calls the sleep before return the strings back.\nThen I am calling the getStrings three times in Observalb.zip, I expect those three calls to run in parallel, so the total time of execution should be within 2 seconds or maybe 3 seconds the most because the sleep was only 2 seconds.\nHowever, it's taking a total of six seconds.\nHow can I make this to run in parallel so it will finish within 2 seconds ?",
    "type": "SO",
    "link": "https://stackoverflow.com/questions/38234152",
    "question_id": "38234152",
    "resources": {
        "api": [
            {
                "link": "https://developer.android.com/codelabs/advanced-kotlin-coroutines#7",
                "type": "android",
                "content": [
                    "In this codelab, you'll learn how to use the LiveData builder to combine Kotlin coroutines with LiveData in an Android app.",
                    "We'll also use Coroutines Asynchronous Flow, which is a type from the coroutines library for representing an async sequence ( or stream ) of values, to implement the same thing.",
                    "You'll start with an existing app, built using Android Architecture Components, that uses LiveData to get a list of objects from a Room database and display them in a RecyclerView grid layout.",
                    "Here are some code snippets to give you an idea of what you'll be doing.",
                    "Here is the existing code to query the Room database:",
                    "The LiveData will be updated using the LiveData builder and coroutines with additional sorting logic:",
                    "You'll also implement the same logic with Flow:",
                    "If you run into any issues ( code bugs, grammatical errors, unclear wording, etc. ) as you work through this codelab, please report the issue via the `` Report a mistake'' link in the lower left corner of the codelab.",
                    "Click the following link to download all the code for this codelab:",
                    "... or clone the GitHub repository from the command line by using the following command:",
                    "The code for this codelab is in the advanced-coroutines-codelab directory.",
                    "The advanced-coroutines-codelab directory in this repository contains several different modules:",
                    "First, let's see what the starting sample app looks like.",
                    "Follow these instructions to open the sample app in Android Studio.",
                    "When the app first runs, a list of cards appears, each displaying the name and image of a specific plant:",
                    "Each Plant has a growZoneNumber, an attribute that represents the region where the plant is most likely to thrive.",
                    "Users can tap the filter icon to toggle between showing all plants and plants for a specific grow zone, which is hardcoded to zone 9.",
                    "Press the filter button a few times to see this in action.",
                    "This app uses Architecture Components to separate the UI code in MainActivity and PlantListFragment from the application logic in PlantListViewModel.",
                    "PlantRepository provides a bridge between the ViewModel and PlantDao, which accesses the Room database to return a list of Plant objects.",
                    "The UI then takes this list of plants and displays them in RecyclerView grid layout.",
                    "A Repository is a bridge between a ViewModel and the data",
                    "In addition to being the bridge, a repository can be accessed by any ViewModel that wants to use its logic.",
                    "It can also combine the logic from multiple data sources, which we will be implemented later.",
                    "Before we start modifying the code, let's take a quick look at how the data flows from the database to the UI.",
                    "Here is how the list of plants are loaded in the ViewModel:",
                    "A GrowZone is an inline class that only contains an Int representing its zone.",
                    "NoGrowZone represents the absence of a zone, and is only used for filtering.",
                    "The growZone is toggled when the filter button is tapped.",
                    "We use a switchMap to determine the list of plants to return.",
                    "A switchMap applies a given function to the input LiveData ( growZone in this case ) and returns the transformed result as a LiveData.",
                    "Here is what the repository and Data Access Object ( DAO ) look like for fetching the plant data from the database:",
                    "While most of the code modifications are in PlantListViewModel and PlantRepository, it's a good idea to take a moment to familiarize yourself with the structure of the project, focusing on how the plant data surfaces through the various layers from the database to the Fragment.",
                    "In the next step, we'll modify the code to add custom sorting using the LiveData builder.",
                    "The list of plants are currently displayed in alphabetical order, but we want to change the order of this list by listing certain plants first, and then the rest in alphabetical order.",
                    "This is similar to shopping apps displaying sponsored results at the top of a list of items available for purchase.",
                    "Our product team wants the ability to change the sort order dynamically without shipping a new version of the app, so we'll fetch the list of plants to sort first from the backend.",
                    "Here's what the app will look like with custom sorting:",
                    "The custom sort order list consists of these four plants: Orange, Sunflower, Grape, and Avocado.",
                    "Notice how they appear first in the list, then followed by the rest of the plants in alphabetical order.",
                    "Now if the filter button is pressed ( and only GrowZone 9 plants are displayed ), the Sunflower disappears from the list since its GrowZone is not 9.",
                    "The other three plants in the custom sort list are in GrowZone 9, so they'll remain at the top of the list.",
                    "The only other plant in GrowZone 9 is the Tomato, which appears last in this list.",
                    "Let's start writing code to implement the custom sort.",
                    "We'll begin by writing a suspending function to fetch the custom sort order from the network and then cache it in memory.",
                    "Add the following to PlantRepository:",
                    "plantsListSortOrderCache is used as the in-memory cache for the custom sort order.",
                    "It will fallback to an empty list if there's a network error, so that our app can still display data even if the sorting order isn't fetched.",
                    "This code uses the CacheOnSuccess utility class provided in the sunflower module to handle caching.",
                    "By abstracting away the details of implementing caching like this, the application code can be more straightforward.",
                    "Since CacheOnSuccess is already well tested, we don't need to write as many tests for our repository to ensure the correct behavior.",
                    "It's a good idea to introduce similar higher-level abstractions in your code when using kotlinx-coroutines.",
                    "Now let's incorporate some logic to apply the sort to a list of plants.",
                    "This extension function will rearrange the list, placing Plants that are in the customSortOrder at the front of the list.",
                    "Now that the sorting logic is in place, replace the code for plants and getPlantsWithGrowZone with the LiveData builder below:",
                    "Now if you run the app, the custom sorted plant list should appear:",
                    "The LiveData builder allows us to calculate values asynchronously, as liveData is backed by coroutines.",
                    "Here we have a suspend function to fetch a LiveData list of plants from the database, while also calling a suspend function to get the custom sort order.",
                    "We then combine these two values to sort the list of plants and return the value, all within the builder.",
                    "You can emit multiple values from a LiveData by calling the emitSource ( ) function whenever you want to emit a new value.",
                    "Note that each call to emitSource ( ) removes the previously-added source.",
                    "The coroutine starts execution when it is observed, and is cancelled when the coroutine successfully finishes or if either the database or network call fails.",
                    "If any of the suspend function calls fail, the entire block is canceled and not restarted, which helps avoid leaks.",
                    "In the next step, we'll explore a variation of getPlantsWithGrowZone using a Transformation.",
                    "We'll now modify PlantRepository to implement a suspending transform as each value is processed, learning how to build complex async transforms in LiveData.",
                    "As a prerequisite, let's create a version of the sorting algorithm that's safe to use on the main thread.",
                    "We can use withContext to switch to another dispatcher just for the lambda and then resume on the dispatcher we started with.",
                    "To switch between any dispatcher, coroutines uses withContext.",
                    "Calling withContext switches to the other dispatcher just for the lambda then comes back to the dispatcher that called it with the result of that lambda.",
                    "By default, Kotlin coroutines provides three Dispatchers: Main, IO, and Default.",
                    "The IO dispatcher is optimized for IO work like reading from the network or disk, while the Default dispatcher is optimized for CPU intensive tasks.",
                    "We can then use this new main-safe sort with the LiveData builder.",
                    "Update the block to use a switchMap, which will let you point to a new LiveData every time a new value is received.",
                    "Compared to the previous version, once the custom sort order is received from the network, it can then be used with the new main-safe applyMainSafeSort.",
                    "This result is then emitted to the switchMap as the new value returned by getPlantsWithGrowZone.",
                    "Similar to plants LiveData above, the coroutine starts execution when it is observed and is terminated either on completion or if either the database or network call fails.",
                    "The difference here is that it's safe to make the network call in the map since it is cached.",
                    "Now let's take a look at how this code is implemented with Flow, and compare the implementations.",
                    "We're going to build the same logic using Flow from kotlinx-coroutines.",
                    "Before we do that, let's take a look at what a flow is and how you can incorporate it into your app.",
                    "A flow is an asynchronous version of a Sequence, a type of collection whose values are lazily produced.",
                    "Just like a sequence, a flow produces each value on-demand whenever the value is needed, and flows can contain an infinite number of values.",
                    "So, why did Kotlin introduce a new Flow type, and how is it different than a regular sequence ?",
                    "The answer lies in the magic of asynchronicity.",
                    "Flow includes full support for coroutines.",
                    "That means you can build, transform, and consume a Flow using coroutines.",
                    "You can also control concurrency, which means coordinating the execution of several coroutines declaratively with Flow.",
                    "This opens up a lot of exciting possibilities.",
                    "A Flow is an async sequence of values",
                    "Flow produces values one at a time ( instead of all at once ) that can generate values from async operations like network requests, database calls, or other async code.",
                    "It supports coroutines throughout its API, so you can transform a flow using coroutines as well !",
                    "Flow can be used in a fully-reactive programming style.",
                    "If you've used something like RxJava before, Flow provides similar functionality.",
                    "Application logic can be expressed succinctly by transforming a flow with functional operators such as map, flatMapLatest, combine, and so on.",
                    "Flow also supports suspending functions on most operators.",
                    "This lets you do sequential async tasks inside an operator like map.",
                    "By using suspending operations inside of a flow, it often results in shorter and easier to read code than the equivalent code in a fully-reactive style.",
                    "In this codelab, we're going to explore using both approaches.",
                    "To get used to how Flow produces values on demand ( or lazily ), take a look at the following flow that emits the values ( 1, 2, 3 ) and prints before, during, and after each item is produced.",
                    "If you run this, it produces this output:",
                    "You can see how execution bounces between the collect lambda and the flow builder.",
                    "Every time the flow builder calls emit, it suspends until the element is completely processed.",
                    "Then, when another value is requested from the flow, it resumes from where it left off until it calls emit again.",
                    "When the flow builder completes, the Flow is cancelled and collect resumes, letting and the calling coroutine prints `` flow is completed.''",
                    "The call to collect is very important.",
                    "Flow uses suspending operators like collect instead of exposing an Iterator interface so that it always knows when it's being actively consumed.",
                    "More importantly, it knows when the caller can't request any more values so it can cleanup resources.",
                    "Flow is built from the ground up using coroutines.",
                    "By using the suspend and resume mechanism of coroutines, they can synchronize the execution of the producer ( flow ) with the consumer ( collect ).",
                    "If you've used reactive streams and are familiar with the concept of backpressure, it is implemented in Flow by suspending a coroutine.",
                    "The Flow in the above example starts running when the collect operator runs.",
                    "Creating a new Flow by calling the flow builder or other APIs does not cause any work to execute.",
                    "The suspending operator collect is called a terminal operator in Flow.",
                    "There are other suspending terminal operators such as toList, first and single shipped with kotlinx-coroutines, and you can build your own.",
                    "By default Flow will execute:",
                    "These rules are the default behavior of Flow and it is possible to make a Flow that has shared state with previous runs, doesn't restart for every terminal operator, and executes independently of collection with built-in or custom transformations of a Flow.",
                    "Executing a Flow is called collecting a flow.",
                    "By default, a Flow will not do anything until it has been collected which means applying any terminal operator.",
                    "myFlow.toList ( ) / / toList collects this flow and adds the values to a List",
                    "We also say an individual value is collected from the Flow by a terminal operator.",
                    "myFlow.collect -LCB- item - > println ( `` $ item has been collected'' ) -RCB-",
                    "Because of these rules, a Flow can participate in structured concurrency, and it's safe to start long-running coroutines from a Flow.",
                    "There's no chance a Flow will leak resources, since they're always cleaned up using coroutine cooperative cancellation rules when the caller is cancelled.",
                    "Lets modify the flow above to only look at the first two elements using the take operator, then collect it twice.",
                    "Running this code, you'll see this output:",
                    "The flow lambda starts from the top each time collect is called.",
                    "This is important if the flow performed expensive work like making a network request.",
                    "Also, since we applied the take ( 2 ) operator, the flow will only produce two values.",
                    "It will not resume the flow lambda again after the second call to emit, so the line `` second value collected ...'' will never print.",
                    "By default, a Flow will restart from the top every time a terminal operator is applied.",
                    "This is important if the Flow performs expensive work, such as making a network request.",
                    "OK, so Flow is lazy like a Sequence, but how is it also async ?",
                    "Let's take a look at an example of an async sequence -- observing changes to a database.",
                    "In this example, we need to coordinate data produced on a database thread pool with observers that live on another thread such as the main or UI thread.",
                    "And, since we'll be emitting results repeatedly as the data changes, this scenario is a natural fit for an async sequence pattern.",
                    "Imagine you're tasked with writing the Room integration for Flow.",
                    "If you started with the existing suspend query support in Room, you might write something like this:",
                    "This code relies upon two imaginary suspending functions to generate a Flow:",
                    "When collected, the flow initially emits the first value of the query.",
                    "Once that value is processed, the flow resumes and calls suspendUntilChanged, which will do as it says -- suspend the flow until one of the tables changes.",
                    "At this point, nothing is happening in the system until one of the tables changes and the flow resumes.",
                    "When the flow resumes, it makes another main-safe query, and emits the results.",
                    "This process continues forever in an infinite loop.",
                    "But wait -- we don't want to leak work !",
                    "The coroutine isn't very expensive by itself, but it repeatedly wakes itself up to perform a database query.",
                    "That's a pretty expensive thing to leak.",
                    "Even though we've created an infinite loop, Flow helps us out by supporting structured concurrency.",
                    "The only way to consume values or iterate over a flow is to use a terminal operator.",
                    "Because all terminal operators are suspend functions, the work is bound to the lifetime of the scope that calls them.",
                    "When the scope is cancelled, the flow will automatically cancel itself using the regular coroutine cooperative cancellation rules.",
                    "So, even though we've written an infinite loop in our flow builder, we can safely consume it without leaks due to structured concurrency.",
                    "Because a flow allows you to consume values only with terminal operators, it can support structured concurrency.",
                    "When the consumer of a flow is cancelled, the entire Flow is cancelled.",
                    "Due to structured concurrency, it is impossible to leak a coroutine from an intermediate step",
                    "In this step, you learn how to use Flow with Room and wire it up to the UI.",
                    "This step is common for many usages of Flow.",
                    "When used this way, the Flow from Room operates as an observable database query similar to a LiveData.",
                    "To get started, open up PlantDao.kt, and add two new queries that return Flow < List <Plant> >:",
                    "Note that except for the return types, these functions are identical to the LiveData versions.",
                    "But, we'll develop them side-by-side to compare them.",
                    "In this codelab, we're going to build the same database transform using the LiveData builder and Flow.",
                    "In a production app, you would only include one of these, but it's useful to compare them to each other to see how they work.",
                    "By specifying a Flow return type, Room executes the query with the following characteristics:",
                    "Put together, this makes Flow a great return type for observing the database from the UI layer.",
                    "To continue wiring up the new return values to the UI, open up PlantRepository.kt, and add the following code:",
                    "For now, we're just passing the Flow values through to the caller.",
                    "This is exactly the same as when we started this codelab with passing the LiveData through to the ViewModel.",
                    "In PlantListViewModel.kt, let's start simple and just expose the plantsFlow.",
                    "We'll come back and add the grow zone toggle to the flow version in the next few steps.",
                    "Again, we'll keep the LiveData version ( val plants ) around for comparison as we go.",
                    "Since we want to keep LiveData in the UI layer for this codelab, we'll use the asLiveData extension function to convert our Flow into a LiveData.",
                    "Just like the LiveData builder, this adds a configurable timeout to the LiveData generated.",
                    "This is nice because it keeps us from restarting our query every time the configuration changes ( such as from device rotation ).",
                    "The asLiveData operator converts a Flow into a LiveData with a configurable timeout.",
                    "Just like the liveData builder, the timeout will help the Flow survive restart.",
                    "If another screen observes before the timeout, the Flow won't be cancelled.",
                    "Since flow offers main-safety and the ability to cancel, you can choose to pass the Flow all the way through to the UI layer without converting it to a LiveData.",
                    "However, for this codelab we will stick to using LiveData in the UI layer.",
                    "Also in the ViewModel, add a cache update to the init block.",
                    "This step is optional for now, but if you clear your cache and don't add this call, you will not see any data in the app.",
                    "Open PlantListFragment.kt, and change the subscribeUi function to point to our new plantsUsingFlow LiveData.",
                    "If you run the app again, you should see that you're now loading the data using Flow !",
                    "Since we haven't implemented the switchMap yet, the filter option doesn't do anything.",
                    "In the next step we'll take a look at transforming the data in a Flow.",
                    "In this step, you'll apply the sort order to plantsFlow.",
                    "We'll do this using the declarative API of flow.",
                    "Declarative is an API style that means describing what your program should do instead of how to do it.",
                    "One of the more commonly known declarative languages is SQL, which allows developers to express what they would like the database to query instead of how to perform the query.",
                    "By using transforms like map, combine, or mapLatest, we can express how we would like to transform each element as it moves through the flow declaratively.",
                    "It even lets us express concurrency declaratively, which can really simplify code.",
                    "In this section, you'll see how you can use operators to tell Flow to launch two coroutines and combine their results declaratively.",
                    "To get started, open up PlantRepository.kt and define a new private flow called customSortFlow:",
                    "This defines a Flow that, when collected, will call getOrAwait and emit the sort order.",
                    "Since this flow only emits a single value, you can also build it directly from the getOrAwait function using asFlow.",
                    "This code creates a new Flow that calls getOrAwait and emits the result as its first and only value.",
                    "It does this by referencing the getOrAwait method using:: and calling asFlow on the resulting Function object.",
                    "Both of these flows do the same thing, call getOrAwait and emit the result before completing.",
                    "Now that we have two flows, customSortFlow and plantsFlow, let's combine them declaratively !",
                    "Add a combine operator to plantsFlow:",
                    "The combine operator combines two flows together.",
                    "Both flows will run in their own coroutine, then whenever either flow produces a new value the transformation will be called with the latest value from either flow.",
                    "By using combine, we can combine the cached network lookup with our database query.",
                    "Both of them will run on different coroutines concurrently.",
                    "That means that while Room starts the network request, Retrofit can start the network query.",
                    "Then, as soon as a result is available for both flows, it will call the combine lambda where we apply the loaded sort order to the loaded plants.",
                    "The transformation combine will launch one coroutine for each flow being combined.",
                    "This lets you combine two flows concurrently.",
                    "It will combine the flows in a `` fair'' manner, which means that they'll all get a chance to produce a value ( even if one of them is produced by a tight loop ).",
                    "To explore how the combine operator works, modify customSortFlow to emit twice with a substantial delay in onStart like this:",
                    "The transform onStart will happen when an observer listens before other operators, and it can emit placeholder values.",
                    "So here we're emitting an empty list, delaying calling getOrAwait by 1500ms, then continuing the original flow.",
                    "If you run the app now, you'll see that the Room database query returns right away, combining with the empty list ( which means it'll sort alphabetically ).",
                    "Then around 1500ms later, it applies the custom sort.",
                    "Before continuing with the codelab, remove the onStart transform from the customSortFlow.",
                    "You can use onStart to run suspending code before a flow runs.",
                    "It can even emit extra values into the flow, so you could use it to emit a Loading state on a network request flow.",
                    "Flow can call main-safe functions, like we're doing here, and it will preserve the normal main-safety guarantees of coroutines.",
                    "Both Room and Retrofit will give us main-safety, and we don't need to do anything else to make network requests or database queries with Flow.",
                    "This flow uses the following threads already:",
                    "So if all we were doing was calling suspend functions in Retrofit and and using Room flows, we wouldn't need to complicate this code with main-safety concerns.",
                    "However, as our data set grows in size, the call to applySort may become slow enough to block the main thread.",
                    "Flow offers a declarative API called flowOn to control which thread the flow runs on.",
                    "Add flowOn to the plantsFlow like this:",
                    "Calling flowOn has two important effects on how the code executes:",
                    "This is very similar to how withContext works to switch dispatchers, but it does introduce a buffer in the middle of our transforms that changes how the flow works.",
                    "The coroutine launched by flowOn is allowed to produce results faster than the caller consumes them, and it will buffer a large number of them by default.",
                    "In this case, we plan on sending the results to the UI, so we would only ever care about the most recent result.",
                    "That's what the conflate operator does -- it modifies the buffer of flowOn to store only the last result.",
                    "If another result comes in before the previous one is read, it gets overwritten.",
                    "The operator flowOn launches a new coroutine to collect the flow above it and introduces a buffer to write the results.",
                    "You can control the buffer with more operators, such as conflate which says to store only the last value produced in the buffer.",
                    "It's important to be aware of the buffer when using flowOn with large objects such as Room results since it is easy to use a large amount of memory buffering results.",
                    "If you run the app again, you should see that you're now loading the data and applying the custom sort order using Flow !",
                    "In the next step we'll take a look at another way to provide main safety using flow.",
                    "To finish up the flow version of this API, open up PlantListViewModel.kt, where we will switch between the flows based on GrowZone like we do in the LiveData version.",
                    "Add the following code below the plants liveData:",
                    "Note, this example uses several @ExperimentalCoroutinesApis, and it is likely that there will be a more concise version in the final version of the Flow APIs.",
                    "This pattern shows how to integrate events ( grow zone changing ) into a flow.",
                    "It does exactly the same thing as the LiveData.switchMap version -- switching between two data sources based on an event.",
                    "This defines a new MutableStateFlow with an initial value of NoGrowZone.",
                    "This is a special kind of Flow value holder that holds only the last value it was given.",
                    "It's a thread-safe concurrency primitive, so you can write to it from multiple threads at the same time ( and whichever is considered `` last'' will win ).",
                    "You can also subscribe to get updates to the current value.",
                    "Overall, it has similar behavior to a LiveData -- it just holds the last value and lets you observe changes to it.",
                    "StateFlow is different from a regular flow created using, for example, the flow -LCB- -RCB- builder.",
                    "A StateFlow is created with an initial value and keeps its state even without being collected and between subsequent collections.",
                    "You can use the MutableStateFlow interface ( as shown above ) to change the value ( state ) of a StateFlow.",
                    "You will often find that flows that behave like StateFlow are called hot, as opposed to regular, cold flows which only execute when they're collected.",
                    "StateFlow is also a regular Flow, so you can use all the operators as you normally would.",
                    "Here we use the flatMapLatest operator which is exactly the same as switchMap from LiveData.",
                    "Whenever the growZone changes its value, this lambda will be applied and it must return a Flow.",
                    "Then, the returned Flow will be used as the Flow for all downstream operators.",
                    "Basically, this lets us switch between different flows based on the value of growZone.",
                    "Flow's flatMapLatest extensions allow you to switch between multiple flows.",
                    "Inside the flatMapLatest, we switch based on the growZone.",
                    "This code is pretty much the same as the LiveData.switchMap version, with the only difference being that it returns Flows instead of LiveDatas.",
                    "And finally, we convert the Flow into a LiveData, since our Fragment expects us to expose a LiveData from the ViewModel.",
                    "The asLiveData operator will convert a Flow into a LiveData with a configurable timeout.",
                    "Just like the liveData builder, the timeout will keep the flow active through rotations so your collection doesn't restart.",
                    "To let the app know about the filter change, we can set MutableStateFlow.value.",
                    "It's an easy way to communicate an event into a coroutine like we're doing here.",
                    "If you run the app again, the filter now works for both the LiveData version and the Flow version !",
                    "In the next step, we'll apply the custom sort to getPlantsWithGrowZoneFlow.",
                    "One of the most exciting features of Flow is its first-class support for suspend functions.",
                    "The flow builder and almost every transform exposes a suspend operator that can call any suspending functions.",
                    "As a result, main-safety for network and database calls as well as orchestrating multiple async operations can be done using calls to regular suspend functions from inside a flow.",
                    "In effect, this allows you to naturally mix declarative transforms with imperative code.",
                    "As you'll see in this example, inside of a regular map operator you can orchestrate multiple async operations without applying any extra transformations.",
                    "In a lot of places, this can lead to substantially simpler code than that of a fully-declarative approach.",
                    "If you've used libraries like RxJava extensively, this is one of the main differences provided by Flow.",
                    "As you get started with Flow, carefully consider how you can use suspending transforms to simplify your code.",
                    "In many cases, you can express async code naturally by leaning on suspending operations inside operators like map, onStart, and onCompletion.",
                    "Familiar operators from Rx like combine, mapLatest, flatMapLatest, flattenMerge, and flatMapMerge are best used to orchestrate concurrency in Flow.",
                    "To wrap up our exploration of Flow, we'll apply the custom sort using suspend operators.",
                    "Open up PlantRepository.kt and add a map transform to getPlantsWithGrowZoneNumberFlow.",
                    "By relying on regular suspend functions to handle the async work, this map operation is main-safe even though it combines two async operations.",
                    "As each result from the database is returned, we'll get the cached sort order -- and if it's not ready yet, it will wait on the async network request.",
                    "Then once we have the sort order, it's safe to call applyMainSafeSort, which will run the sort on the default dispatcher.",
                    "This code is now entirely main-safe by deferring the main safety concerns to regular suspend functions.",
                    "It's quite a bit simpler than the same transformation implemented in plantsFlow.",
                    "In Flow, map and other operators accept a suspending lambda.",
                    "By using the suspend and resume mechanism of coroutines, you can often orchestrate sequential async calls easily without using declarative transforms.",
                    "It is an error to emit a value from a different coroutine than the one that called the suspending transformation.",
                    "If you do launch another coroutine inside a flow operation like we're doing here inside getOrAwait and applyMainSafeSort, make sure the value is returned to the original coroutine before emitting it.",
                    "However, it is worth noting that it will execute a bit differently.",
                    "The cached value will be fetched every single time the database emits a new value.",
                    "This is OK because we're caching it correctly in plantsListSortOrderCache, but if that started a new network request this implementation would make a lot of unnecessary network requests.",
                    "combine version, the network request and the database query run concurrently, while in this version they run in sequence.",
                    "Due to these differences, there is not a clear rule to structure this code.",
                    "In many cases, it's fine to use suspending transformations like we're doing here, which makes all async operations sequential.",
                    "However, in other cases, it's better to use operators to control concurrency and provide main-safety.",
                    "As one final ( optional ) step, let's move the network requests into a flow-based coroutine.",
                    "By doing so, we'll remove the logic for making the network calls from the handlers called by onClick and drive them from the growZone.",
                    "This helps us create a single source of truth and avoid code duplication -- there's no way any code can change the filter without refreshing the cache.",
                    "Open up PlantListViewModel.kt, and add this to the init block:",
                    "This code will launch a new coroutine to observe the values sent to growZoneChannel.",
                    "You can comment out the network calls in the methods below now as they're only needed for the LiveData version.",
                    "If you run the app again now, you'll see that the network refresh is now controlled by the growZone !",
                    "We've improved the code substantially, as more ways to change the filter come in the channel acts as a single source of truth for which filter is active.",
                    "That way the network request and the current filter can never get out of sync.",
                    "Let's step through all the new functions used one at a time, starting from the outside:",
                    "This time, we use the launchIn operator to collect the flow inside our ViewModel.",
                    "The operator launchIn creates a new coroutine and collects every value from the flow.",
                    "It'll launch in the CoroutineScope provided -- in this case, the viewModelScope.",
                    "This is great because it means when this ViewModel gets cleared, the collection will be cancelled.",
                    "Without providing any other operators, this doesn't do very much -- but since Flow provides suspending lambdas in all of its operators it's easy to make async actions based on every value.",
                    "Using Flow, it's natural to collect data in the ViewModel, Repository, or other data layers when needed.",
                    "Since Flow is not tied to the UI, you don't need a UI observer to collect a flow.",
                    "This is a big difference from LiveData which always requires a UI-observer to run.",
                    "It is not a good idea to try to observe a LiveData in your ViewModel because it doesn't have an appropriate observation lifecycle.",
                    "This is where the magic lies -- mapLatest will apply this map function for each value.",
                    "However, unlike regular map, it'll launch a new coroutine for each call to the map transform.",
                    "Then, if a new value is emitted by the growZoneChannel before the previous coroutine completes, it'll cancel it before starting a new one.",
                    "We can use mapLatest to control concurrency for us.",
                    "Instead of building cancel/restart logic ourselves, the flow transform can take care of it.",
                    "This code saves a lot of code and complexity compared to writing the same cancellation logic by hand.",
                    "Cancellation of a Flow follows the normal cooperative cancellation rules of coroutines.",
                    "If you've used RxJava, you can use mapLatest exactly like you'd use switchMap.",
                    "The key difference is that it provides a suspending lambda for you in a new coroutine, so you can call regular suspend functions directly from mapLatest.",
                    "onEach will be called every time the flow above it emits a value.",
                    "Here we're using it to reset the spinner after processing is complete.",
                    "The catch operator will capture any exceptions thrown above it in the flow.",
                    "It can emit a new value to the flow like an error state, rethrow the exception back into the flow, or perform work like we're doing here.",
                    "When there's an error we're just telling our _ snackbar to display the error message.",
                    "This step showed you how you can control concurrency using Flow, as well as consume Flows inside a ViewModel without depending on a UI observer.",
                    "As a challenge step, try to define a function to encapsulate the data loading of this flow with the following signature:",
                    "Experience with the Architecture Components ViewModel, LiveData, Repository, and Room.",
                    "Experience with Kotlin syntax, including extension functions and lambdas.",
                    "A basic understanding of using threads on Android, including the main thread, background threads, and callbacks.",
                    "For an introduction to the Architecture Components used in this codelab, see Room with a View.",
                    "For an introduction to Kotlin syntax, see Kotlin Bootcamp for Programmers.",
                    "For an introduction to Kotlin Coroutines, see Using Kotlin Coroutines in your Android App",
                    "Convert an existing LiveData to use the Kotlin coroutines-friendly LiveData builder.",
                    "Add logic within a LiveData builder.",
                    "Use Flow for asynchronous operations.",
                    "Combine Flows and transform multiple asynchronous sources.",
                    "Learn how to choose between LiveData and Flow.",
                    "Android Studio 4.1 or above.",
                    "The codelab may work with other versions, but some things might be missing or look different.",
                    "start -- code to modify for this codelab.",
                    "finished_code -- the code for the completed codelab.",
                    "Refer to this module if you run into issues.",
                    "sunflower -- supporting app code.",
                    "We will not make modifications to code in this module.",
                    "How do I install Android Studio ?",
                    "How do I set up a device for development ?",
                    "If you downloaded the kotlin-coroutines zip file, unzip the file.",
                    "Open the advanced-coroutines-codelab directory in Android Studio.",
                    "Make sure start is selected in the configuration drop-down.",
                    "Click the Run button, and either choose an emulated device or connect your Android device.",
                    "The device must be capable of running Android Lollipop ( the minimum supported SDK is 21 ).",
                    "This codelab's app is based on the Android Sunflower open source sample",
                    "Fun fact: the growZoneNumber is loosely based on the United States Department of Agriculture's Plant Hardiness Zone Map",
                    "Every time a terminal operator is applied ( and each new invocation is independent from any previously started ones )",
                    "Until the coroutine it is running in is cancelled",
                    "When the last value has been fully processed, and another value has been requested",
                    "suspendQuery -- a main-safe function that runs a regular Room suspend query",
                    "suspendUntilChanged -- a function that suspends the coroutine until one of the tables changes",
                    "Main-safety -- Queries with a Flow return type always run on the Room executors, so they are always main-safe.",
                    "You don't need to do anything in your code to make them run off the main thread.",
                    "Observes changes -- Room automatically observes changes and emits new values to the flow.",
                    "Async sequence -- Flow emits the entire query result on each change, and it won't introduce any buffers.",
                    "If you return a Flow < List <T> >, the flow emits a List <T> that contains all rows from the query result.",
                    "It will execute just like a sequence -- emitting one query result at a time and suspending until it is asked for the next one.",
                    "Cancellable -- When the scope that's collecting these flows is cancelled, Room cancels observing this query.",
                    "plantService.customPlantSortOrder runs on a Retrofit thread ( it calls Call.enqueue )",
                    "getPlantsFlow will run queries on a Room Executor",
                    "applySort will run on the collecting dispatcher ( in this case Dispatchers.Main )",
                    "Launch a new coroutine on the defaultDispatcher ( in this case, Dispatchers.Default ) to run and collect the flow before the call to flowOn.",
                    "Introduces a buffer to send results from the new coroutine to later calls.",
                    "Emit the values from that buffer into the Flow after flowOn.",
                    "In this case, that's asLiveData in the ViewModel.",
                    ""
                ],
                "title": "Learn advanced coroutines with Kotlin Flow and LiveData"
            }
        ],
        "git": [
            {
                "link": "https://github.com/ReactiveX/RxJava/issues/627",
                "content": [
                    "Add a parallel execution function for processing a single emitted item over different parallel fucntions \u00b7 Issue # 627 \u00b7 ReactiveX/RxJava \u00b7 GitHub",
                    "Add a parallel execution function for processing a single emitted item over different parallel fucntions",
                    "We have the following use case.",
                    "We create an observable which emits a single value.",
                    "This value passes through a couple of standard Rx map functions sequentially.",
                    "After the sequential functions it then needs to have multiple validation functions to be executed concurrently.",
                    "These are slow operations, since they require I/O with external systems.",
                    "If we can perform them in parallel, we can significantly reduce our users's perceived execution time.",
                    "Note that this is different than the current parallel and parallelMap functions.",
                    "These perform the same function over multiple emitted items.",
                    "I need to perform multiple different functions in parallel over a single emitted value.",
                    "It seems that the last step might need to be a zip or similar so that the user can provide an aggregation function and then emit a single value from the result of the parallel aggregation.",
                    "The text was updated successfully, but these errors were encountered:",
                    "Are you looking for something like this ?",
                    "However in my case the functions themselves are quite complex and touch a lot of integration points.",
                    "Rather than have them as embedded functions, I create classes that implements Func1 or Action1.",
                    "Therefore, I need the ability to have both Func1 or Action1 to be invoked.",
                    "This allows us to unit test each of our complex functions or actions, and receive the input as an argument to the `` call'' method.",
                    "You can see an example of how we do this at Netflix here: https://speakerdeck.com/benjchristensen/rxjava-goto-aarhus-2013?slide=142",
                    "Inside a flatMap we kick off multiple async calls ( you can do computation whereas we do IO ) and then merge or zip them together.",
                    "Use merge if you don't care about their ordering or getting them back all at once.",
                    ""
                ],
                "title": "Add a parallel execution function for processing a single emitted item over different parallel fucntions \u00b7 Issue # 627 \u00b7 ReactiveX/RxJava \u00b7 GitHub"
            }
        ],
        "qa": [
            {
                "uid": "35357919",
                "link": "https://stackoverflow.com/questions/35357919",
                "title": "Combine a list of Observables and wait until all completed",
                "answers": [
                    {
                        "uid": 35358485,
                        "score": 2,
                        "text": [
                            "You probably looked at the zip operator that works with 2 Observables.",
                            "There is also the static method Observable.zip.",
                            "It has one form which should be useful for you:",
                            "You can check out the LINK"
                        ]
                    },
                    {
                        "uid": 35363084,
                        "score": 74,
                        "text": [
                            "It sounds like you're looking for the LINK.",
                            "There are a few different ways of using it, so let's look at an example.",
                            "Say we have a few simple observables of different types:",
                            "The simplest way to wait for them all is something like this:",
                            "Note that in the zip function, the parameters have concrete types that correspond to the types of the observables being zipped.",
                            "Zipping a list of observables is also possible, either directly:",
                            "... or by wrapping the list into an Observable < Observable < ?",
                            ">>:",
                            "However, in both of these cases, the zip function can only accept a single Object -LSB- -RSB- parameter since the types of the observables in the list are not known in advance as well as their number.",
                            "This means that that the zip function would have to check the number of parameters and cast them accordingly.",
                            "Regardless, all of the above examples will eventually print 1 Blah true",
                            "EDIT: When using Zip, make sure that the Observables being zipped all emit the same number of items.",
                            "In the above examples all three observables emitted a single item.",
                            "If we were to change them to something like this:",
                            "Then 1, Blah, True and 2, Hello, True would be the only items passed into the zip function -LRB- s -RRB-.",
                            "The item 3would never be zipped since the other observables have completed."
                        ]
                    },
                    {
                        "uid": 35365371,
                        "score": 80,
                        "text": [
                            "You can use flatMap in case you have dynamic tasks composition.",
                            "Something like this:",
                            "LINK",
                            "Note: I do not really know your requirements for error handling.",
                            "For example what to do if only one task fails.",
                            "I think you should verify this scenario."
                        ]
                    },
                    {
                        "uid": 46747875,
                        "score": 1,
                        "text": [
                            "I'm writing some computation heave code in Kotlin with JavaRx Observables and RxKotlin.",
                            "I want to observe a list of observables to be completed and in the meantime giving me an update with the progress and latest result.",
                            "At the end it returns the best calculation result.",
                            "An extra requirement was to run Observables in parallel for using all my cpu cores.",
                            "I ended up with this solution:"
                        ]
                    },
                    {
                        "uid": 49509727,
                        "score": 2,
                        "text": [
                            "With Kotlin",
                            "It's important to set the type for the function's arguments or you will have compilation errors",
                            "The last argument type change with the number of argument: BiFunction for 2 Function3 for 3 Function4 for 4 ..."
                        ]
                    },
                    {
                        "uid": 52004664,
                        "score": 16,
                        "text": [
                            "Of the suggestions proposed, LINK actually combines observable results with each other, which may or may not be what is wanted, but was not asked in the question.",
                            "In the question, all that was wanted was execution of each of the operations, either one-by-one or in parallel -LRB- which was not specified, but linked Bolts example was about parallel execution -RRB-.",
                            "Also, zip -LRB- -RRB- will complete immediately when any of the observables complete, so it's in violation of the requirements.",
                            "For parallel execution of Observables, flatMap -LRB- -RRB- LINK is fine, but LINK would be more straight-forward.",
                            "Note that merge will exit on error of any of the Observables, if you rather postpone the exit until all observables have finished, you should be looking at LINK.",
                            "For one-by-one, I think LINK should be used.",
                            "Its javadoc states like this:",
                            "concat -LRB- java.lang.Iterable > sequences -RRB- Flattens an Iterable of Observables into one Observable, one after the other, without interleaving them",
                            "which sounds like what you're after if you don't want parallel execution.",
                            "Also, if you're only interested in the completion of your task, not return values, you should probably look into LINK instead of LINK.",
                            "TLDR: for one-by-one execution of tasks and oncompletion event when they are completed, I think Completable.concat -LRB- -RRB- is best suited.",
                            "For parallel execution, Completable.merge -LRB- -RRB- or Completable.mergeDelayError -LRB- -RRB- sounds like the solution.",
                            "The former one will stop immediately on any error on any completable, the latter one will execute them all even if one of them has an error, and only then reports the error."
                        ]
                    },
                    {
                        "uid": 58575631,
                        "score": 0,
                        "text": [
                            "I had similar problem, I needed to fetch search items from rest call while also integrate saved suggestions from a RecentSearchProvider.AUTHORITY and combine them together to one unified list.",
                            "I was trying to use @MyDogTom solution, unfortunately there is no Observable.from in RxJava.",
                            "After some research I got a solution that worked for me.",
                            "I created an observable from the array of observables that contains lists of suggestions and results from the internet depending on the query.",
                            "After that you just go over those tasks with flatMapIterable and run them using flatmap, place the results in array, which can be later fetched into a recycle view."
                        ]
                    },
                    {
                        "uid": 62929998,
                        "score": 0,
                        "text": [
                            "If you use Project Reactor, you can use Mono.when."
                        ]
                    }
                ],
                "tags": [
                    "java",
                    "rx-java",
                    "reactive-programming",
                    "rx-android"
                ]
            }
        ],
        "other": [
            {
                "link": "https://dzone.com/articles/rxjava-idiomatic-concurrency-flatmap-vs-parallel",
                "type": "misc",
                "content": [
                    "Thanks for visiting DZone today,",
                    "How to Post to DZone",
                    "Over 2 million developers have joined DZone.",
                    "DZone > Java Zone > RxJava: Idiomatic Concurrency -- flatMap ( ) vs. parallel ( )",
                    "RxJava: Idiomatic Concurrency -- flatMap ( ) vs. parallel ( )",
                    "When it comes to concurrent programming using the RxJava library, here's a breakdown of flatMap ( ) and parallel ( ) and some guidance as to which is the most helpful.",
                    "Sep. 15, 17 \u00b7 Java Zone",
                    "Join the DZone community and get the full member experience.",
                    "Simple, effective, and safe concurrency was one of the design principles of RxJava.",
                    "Yet, ironically, it's probably one of the most misunderstood aspects of this library.",
                    "Let's take a simple example: Imagine we have a bunch of UUIDs, and for each one of them, we must perform a set of tasks.",
                    "The first problem is to perform I/O-intensive operations per each UUID, for example loading an object from a database:",
                    "First, I'm generating 100 random UUIDs just for the sake of testing.",
                    "Then, for each UUID, I'd like to load a record using the following method:",
                    "The implementation of slowLoadBy ( ) is irrelevant -- just keep in mind it's slow and blocking.",
                    "Using subscribe ( ) to invoke slowLoadBy ( ) has many disadvantages:",
                    "subscribe ( ) is single-threaded by design and there is no way around it.",
                    "Each UUID is loaded sequentially.",
                    "When you call subscribe ( ), you can not transform the Person object further.",
                    "A more robust, and even more broken, approach is to map ( ) each UUID:",
                    "This is very readable, but unfortunately broken.",
                    "Operators, just like subscribers, are single-threaded.",
                    "This means at any given time, only one UUID can be mapped -- no concurrency is allowed here as well.",
                    "To make matters worse, we are inheriting a thread/worker from upstream.",
                    "If the upstream produces events using some dedicated scheduler, we will hijack threads from that scheduler.",
                    "For example, many operators, like interval ( ), use the Schedulers.computation ( ) thread pool transparently.",
                    "We suddenly start to perform I/O-intensive operations on a pool that is totally not suitable for that.",
                    "Moreover, we slow down the whole pipeline with this one blocking, sequential step.",
                    "You might have heard about this subscribeOn ( ) operator and how it enables concurrency.",
                    "Indeed, but you have to be very careful when applying it.",
                    "The following sample is ( again ) wrong:",
                    "The code snippet above is still broken.",
                    "subscribeOn ( ) ( and observeOn ( ) for that matter ) barely switch execution to a different worker ( thread ) without introducing any concurrency.",
                    "The stream still sequentially processes all events, but on a different thread.",
                    "In other words, rather than consuming events sequentially on a thread inherited from upstream, we now consume them sequentially on the io ( ) thread.",
                    "So what about this mythical flatMap ( ) operator ?",
                    "flatMap ( ) Operator to the Rescue The flatMap ( ) operator enables concurrency by splitting a stream of events into a stream of sub-streams.",
                    "But first, one more broken example:",
                    "Oh gosh, this is still broken !",
                    "The flatMap ( ) operator logically does two things:",
                    "Applies the transformation ( id - > asyncLoadBy ( id ) ) on each upstream event.",
                    "This produces Flowable < Flowable <Person> >.",
                    "This makes sense -- for each upstream UUID, we get a Flowable <Person>, so we end up with a stream of streams of Person objects.",
                    "Then, flatMap ( ) tries to subscribe to all of these inner sub-streams at once.",
                    "Whenever any of the sub-streams emit a Person event, it is transparently passed as an outcome of the outer Flowable.",
                    "Technically, flatMap ( ) only creates and subscribes to the first 128 ( the default of the optional maxConcurrency parameter ) sub-streams.",
                    "Also, when the last substream completes, the outer stream of Person completes as well.",
                    "Now, why on Earth is this broken ?",
                    "RxJava doesn't introduce any thread pool unless explicitly asked for.",
                    "For example, this piece of code is still blocking:",
                    "Look at the output carefully, especially on the order of events and threads involved:",
                    "No concurrency whatsoever, no extra threads.",
                    "Merely wrapping blocking code in a Flowable doesn't magically add concurrency.",
                    "You have to explicitly use ... subscribeOn ( ):",
                    "The output this time is more promising:",
                    "But we did use subscribeOn ( ) last time, so what's going on ?",
                    "Well, subscribeOn ( ) on the outer stream level basically said that all events should be processed sequentially, within this stream, on a different thread.",
                    "We didn't say that there should many sub-streams running concurrently.",
                    "And because all sub-streams are blocking, when RxJava tries to subscribe to all of them, it effectively subscribes sequentially to one after another.",
                    "asyncLoadBy ( ) is not really async, thus it blocks when the flatMap ( ) operator tries to subscribe to it.",
                    "Normally, you would put subscribeOn ( ) inside asyncLoadBy ( ) but for educational purposes, I'll place it directly in the main pipeline:",
                    "Now it works like a charm !",
                    "By default, RxJava will take first 128 upstream events ( UUIDs ), turn them into sub-streams, and subscribe to all of them.",
                    "If sub-streams are asynchronous and highly parallelizable ( e.g. network calls ), we get 128 concurrent invocations of asyncLoadBy ( ).",
                    "The concurrency level ( 128 ) is configurable via the maxConcurrency parameter:",
                    "That was a lot of work, don't you think ?",
                    "Shouldn't concurrency be even more declarative ?",
                    "We no longer deal with Executors and futures, but still, it seems this approach is too error prone.",
                    "Can't it be as simple as parallel ( ) in Java 8 streams ?",
                    "Enter ParallelFlowable Let's look again at our example and make it even more complex by adding filter ( ):",
                    "Where hasLowRisk ( ) is a slow predicate:",
                    "We already know that the idiomatic approach to this problem is using flatMap ( ) twice:",
                    "asyncHasLowRisk ( ) is rather obscure -- it either returns a single-element stream when the predicate passes or an empty stream when it fails.",
                    "This is how you emulate filter ( ) using flatMap ( ).",
                    "Can we do better ?",
                    "Introduced in RxJava 2.0.5, there is a new operator called ... parallel ( ) !",
                    "It's quite surprising because an operator with the same name was removed before RxJava became 1.0 due to many misconceptions surrounding it, leading to it being misused.",
                    "parallel ( ) in 2.x seems to finally address the problem of idiomatic concurrency in a safe and declarative way.",
                    "First, let's see some beautiful code !",
                    "A block of code between parallel ( ) and sequential ( ) runs ... in parallel.",
                    "What do we have here ?",
                    "First of all, the new parallel ( ) operator turns Flowable <UUID> into ParallelFlowable <UUID>, which has a much smaller API than Flowable.",
                    "You'll see in a second why.",
                    "The optional int parameter ( 10 in our case ) defines concurrency, or ( as the documentation puts it ) how many concurrent `` rails'' are created.",
                    "So for us, we split single Flowable <Person> into 10 concurrent, independent rails ( think: threads ).",
                    "Events from original stream of UUIDs are split ( modulo 10 ) into different rails -- sub-streams that are independent of each other.",
                    "Think of them as sending upstream events into 10 separate threads.",
                    "But first, we have to define where these threads come from -- using the handy runOn ( ) operator.",
                    "This is so much better than parallel ( ) on Java 8 streams where you have no control over concurrency level.",
                    "At this point, we have a ParallelFlowable.",
                    "When an event appears upstream ( UUID ), it is delegated to one of 10 `` rails'' -- concurrent, independent pipelines.",
                    "Pipeline provides a limited subset of operators that are safe to run concurrently, e.g. map ( ) and filter ( ), but also reduce ( ).",
                    "There is no buffer ( ), take ( ), etc. as their semantics are unclear when invoked on many sub-streams at once.",
                    "Our blocking slowLoadBy ( ), as well as hasLowRisk ( ), are still invoked sequentially, but only within a single `` rail''.",
                    "Because we now have 10 concurrent `` rails'', we effectively parallelized them without much effort.",
                    "When events reach the end of a sub-stream ( `` rail'' ), they encounter a sequential ( ) operator.",
                    "This operator turns ParallelFlowable back into Flowable.",
                    "As long as our mappers and filters are thread-safe, a parallel ( ) / sequential ( ) pair provides a very easy way of parallelizing streams.",
                    "One small caveat -- you will inevitably get messages reordered.",
                    "Sequential map ( ) and filter ( ) always preserve order ( like most operators ).",
                    "But once you run them within a parallel ( ) block, the order is lost.",
                    "This allows for greater concurrency, but you have to keep that in mind.",
                    "Should you use parallel ( ) rather than nested flatMap ( ) to parallelize your code ?",
                    "It's up to you, but parallel ( ) seems to be much easier to read and grasp.",
                    "java, rxjava, concurrency, parallel, flatmap, tutorial",
                    "Published at DZone with permission of Tomasz Nurkiewicz, DZone MVB.",
                    "See the original article here.",
                    "Opinions expressed by DZone contributors are their own.",
                    "Java: Coding Style or Bad Practice ?",
                    "Top 10 Open Source Projects for SREs and DevOps",
                    "Multithreading Java and Interviews Part 3: Wait and Notify All",
                    "About DZone Send feedback Careers",
                    "Developer Marketing Blog Advertise with DZone +1 (919)\u00a0238-7100",
                    "MVB Program Become a Contributor Visit the Writers' Zone",
                    "Terms of Service Privacy Policy",
                    "600 Park Offices Drive Suite 150 Research Triangle Park, NC 27709 support@dzone.com +1 (919)\u00a0678-0300",
                    ""
                ],
                "title": "RxJava: Idiomatic Concurrency \u2014 flatMap() vs. parallel() - DZone Java"
            },
            {
                "link": "https://proandroiddev.com/rxjava-mistakes-not-so-parallel-execution-of-blocking-tasks-dcb392a12d03",
                "type": "misc",
                "content": [
                    "Sign inSubmitArchiveAboutEventsdroidconRxJava mistakes: ( not so ) parallel execution of blocking tasksPaulina SadowskaFollowAug 18, 2018 \u00b7 3 min readIn this short post, I want to write you about some stupid mistake I made when I wanted to execute two blocking tasks in parallel using RxJava.",
                    "I spent about half an hour debugging my code trying to figure out why it's executed synchronously despite the fact that I use subscribeOn method.",
                    "Now if I think about it it was pretty obvious but I think most bugs seems obvious after you solve them \ud83d\ude09.",
                    "My task was pretty simple.",
                    "I had two long long running blocks of code which I put into separate functions called processData1 ( ) and processData2 ( ).",
                    "None of the functions return any value.",
                    "I wanted to execute them on separate background threads in parallel and notify when they both complete or at least one of it fails.The first step would be to wrap the functions into Completables using Completable.fromAction ( ) method.",
                    "Completable emits either an exception or completes when the task is finished so it ` s perfect for wrapping functions which don't return any value.Merging it togetherTo execute both Completables in parallel they have to be merged using ( not surprisingly ) merge operator.Merge combines multiple Observables ( or in that case Completables ) into one by merging their emissions like shown on the diagram: http://rxmarbles.com/For two completables the diagram can be simplified since completable doesn't emit any value.",
                    "In that case, merge function creates a new completable instance which completes when both completables completes or emits an error.simplified marble diagram for merge operator of two completablesSpecify the schedulerTo execute the tasks on a separate thread it's convenient to use subscribeOn function which allows specifying Scheduler on which a Completable will operate.",
                    "I passed Schedulers.io ( ) scheduler so both actions will be executed on the thread from the IO pool.Resulting code ( with a bug \ud83d\udc1b ) The resulting code is really simple and looks like this: As I mentioned earlier that code has a subtle bug in it.",
                    "If you run that code with some prints you'll see that both tasks are executed on the thread from IO pool but they're both executed on the same thread.The reason is really simple: mergeWith function combines two completables into one and returns a new Completable instance which subscribes to both completables.",
                    "The scheduler won't be applied to each of the completables but only to completable returned by merge.Corrected versionTo both tasks work in parallel subscribeOn should be called on each of the completables that would be merged.And the output finally is correct, both tasks run in parallel on the separate thread from the io pool.What about other operators?The same rule applies not only to the merge operator but also to zip operator which you can use to run a code from two Singles or Observables in parallel and combine their results.Code for parallel execution of two zipped Singles which emit some Strings would look like this: My other posts about RxJava: Unit Testing asynchronous RxJava code ( in Kotlin ) Display progress of multipart request with Retrofit and RxJavaProAndroidDevThe latest posts from Android Professionals and Google ... Follow916 9 RxjavaAndroidAndroid App DevelopmentMobile App DevelopmentAndroidDev916 claps916 claps9 responsesWritten byPaulina SadowskaFollowAndroid DeveloperFollowProAndroidDevFollowThe latest posts from Android Professionals and Google Developer Experts.FollowWritten byPaulina SadowskaFollowAndroid DeveloperProAndroidDevFollowThe latest posts from Android Professionals and Google Developer Experts.More From MediumKotlin.",
                    "Lambda vs Method ReferenceGurgen Gevondov in ProAndroidDevKotlin Multiplatform -- A panacea for mobile app development?Mayank Kharbanda in ProAndroidDevCreate Android Studio plugin to toggle `` Show layout bounds'' ( Part 1 ) Paulina Sadowska in ProAndroidDevArchitecture in Jetpack Compose -- MVP, MVVM, & MVIIan Alexander in ProAndroidDevBetter handling states between ViewModel and ComposableIgor Escodro in ProAndroidDevCompile less with SOLIDIveta Jur\u010d\u00edkov\u00e1 in ProAndroidDevCache data in AndroidRobert Levonyan in ProAndroidDevLet's Make a Countdown Timer app using Android Compose \u23f1 Beg\u00fcm Yaz\u0131c\u0131 \ud83d\udc69\ud83c\udffb\u200d\ud83d\udcbb in ProAndroidDevLearn more.Medium is an open platform where 170 million readers come to find insightful and dynamic thinking.",
                    "Here, expert and undiscovered voices alike dive into the heart of any topic and bring new ideas to the surface.",
                    "Learn moreMake Medium yours.Follow the writers, publications, and topics that matter to you, and you'll see them on your homepage and in your inbox.",
                    "ExploreShare your thinking.If you have a story to tell, knowledge to share, or a perspective to offer -- welcome home.",
                    "It's easy and free to post your thinking on any topic.",
                    "Write on MediumAboutHelpLegalGet the Medium app",
                    "RxJava mistakes: ( not so ) parallel execution of blocking tasksPaulina SadowskaFollowAug 18, 2018 \u00b7 3 min readIn this short post, I want to write you about some stupid mistake I made when I wanted to execute two blocking tasks in parallel using RxJava.",
                    "The scheduler won't be applied to each of the completables but only to completable returned by merge.Corrected versionTo both tasks work in parallel subscribeOn should be called on each of the completables that would be merged.And the output finally is correct, both tasks run in parallel on the separate thread from the io pool.What about other operators?The same rule applies not only to the merge operator but also to zip operator which you can use to run a code from two Singles or Observables in parallel and combine their results.Code for parallel execution of two zipped Singles which emit some Strings would look like this: My other posts about RxJava: Unit Testing asynchronous RxJava code ( in Kotlin ) Display progress of multipart request with Retrofit and RxJava",
                    "RxJava mistakes: ( not so ) parallel execution of blocking tasksPaulina SadowskaFollowAug 18, 2018 \u00b7 3 min read",
                    "Paulina SadowskaFollowAug 18, 2018 \u00b7 3 min read",
                    "ProAndroidDevThe latest posts from Android Professionals and Google ... Follow916 9",
                    "ProAndroidDevThe latest posts from Android Professionals and Google ... Follow",
                    "The latest posts from Android Professionals and Google ...",
                    ""
                ],
                "title": "RxJava mistakes: (not so) parallel execution of blocking tasks | by Paulina Sadowska | ProAndroidDev"
            }
        ]
    },
    "parsed": true
}