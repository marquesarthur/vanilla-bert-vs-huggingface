{
    "task": "Custom Annotations in Retrofit 2.0",
    "description": "According to @JakeWharton in issue https://github.com/square/retrofit/issues/1145 it should be possible to use custom annotations\n\nif i use a custom annotation like \n\n```\nimport javax.ws.rs.HttpMethod;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n@Target(METHOD)\n@Retention(RUNTIME)\n@HttpMethod(value = HttpMethod.DELETE)\npublic @interface DELETE_WITH_BODY {\n    String value();\n}\n```\n\nand use it like this\n\n```\n@DELETE_WITH_BODY(\"/myurl\")\n    Call<String> deactivateUserPermanently(\n            @Header(\"Authorization\") String systemAuthLine,\n            @Body MyBodyRequest myBodyRequest\n    );\n```\n\nI get following stacktrace\n\n```\njava.lang.IllegalArgumentException: HTTP method annotation is required (e.g., @GET, @POST, etc.).\n    for method MyProxy.deactivateUserPermanently\n    at retrofit.Utils.methodError(Utils.java:177)\n    at retrofit.Utils.methodError(Utils.java:167)\n    at retrofit.RequestFactoryParser.parseMethodAnnotations(RequestFactoryParser.java:135)\n    at retrofit.RequestFactoryParser.parse(RequestFactoryParser.java:59)\n    at retrofit.MethodHandler.create(MethodHandler.java:30)\n    at retrofit.Retrofit.loadMethodHandler(Retrofit.java:151)\n    at retrofit.Retrofit$1.invoke(Retrofit.java:132)\n    at com.sun.proxy.$Proxy7.deactivateUserPermanently(Unknown Source)\n    at xxx.xxx.MyGateway.deactivateUserPermanently(MyGateway.java:354)\n```\n\nmaybe I have an error, but i think that should work though\n\nUsing Retrofit 1.9 and that annotation, I can use a HTTP DELETE with body:\n\n```\npackage working.with.retrofit.1_9.like.that;\n\nimport retrofit.http.RestMethod;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n@Target(METHOD)\n@Retention(RUNTIME)\n@RestMethod(value = \"DELETE\", hasBody = true)\npublic @interface DELETE_WITH_BODY {\n    String value();\n}\n\n```\n",
    "type": "GIT",
    "link": "https://github.com/square/retrofit/issues/1150",
    "question_id": "1150",
    "resources": {
        "api": [
            {
                "link": "https://developer.android.com/training/dependency-injection/dagger-android",
                "type": "android",
                "content": [
                    "The Dagger basics page explained how Dagger can help you automate dependency injection in your app.",
                    "With Dagger, you don't have to write tedious and error-prone boilerplate code.",
                    "To use Dagger in your project, add these dependencies to your application in your build.gradle file.",
                    "You can find the latest version of Dagger in this GitHub project.",
                    "Consider an example Android app with the dependency graph from Figure 1.",
                    "Dependency graph of the example code",
                    "In Android, you usually create a Dagger graph that lives in your application class because you want an instance of the graph to be in memory as long as the app is running.",
                    "In this way, the graph is attached to the app lifecycle.",
                    "In some cases, you might also want to have the application context available in the graph.",
                    "For that, you would also need the graph to be in the application class.",
                    "One advantage of this approach is that the graph is available to other Android framework classes.",
                    "Additionally, it simplifies testing by allowing you to use a custom application class in tests.",
                    "Because the interface that generates the graph is annotated with @Component, you can call it ApplicationComponent or ApplicationGraph.",
                    "You usually keep an instance of that component in your custom application class and call it every time you need the application graph, as shown in the following code snippet:",
                    "Because certain Android framework classes such as activities and fragments are instantiated by the system, Dagger can't create them for you.",
                    "For activities specifically, any initialization code needs to go into the onCreate ( ) method.",
                    "That means you can not use the @Inject annotation in the constructor of the class ( constructor injection ) as you did in the previous examples.",
                    "Instead, you have to use field injection.",
                    "Instead of creating the dependencies an activity requires in the onCreate ( ) method, you want Dagger to populate those dependencies for you.",
                    "For field injection, you instead apply the @Inject annotation to the fields that you want to get from the Dagger graph.",
                    "For simplicity, LoginViewModel is not an Android Architecture Components ViewModel ; it's just a regular class that acts as a ViewModel.",
                    "For more information about how to inject these classes, check out the code in the official Android Blueprints Dagger implementation, in the dev-dagger branch.",
                    "One of the considerations with Dagger is that injected fields can not be private.",
                    "They need to have at least package-private visibility like in the preceding code.",
                    "Dagger needs to know that LoginActivity has to access the graph in order to provide the ViewModel it requires.",
                    "In the Dagger basics page, you used the @Component interface to get objects from the graph by exposing functions with the return type of what you want to get from the graph.",
                    "In this case, you need to tell Dagger about an object ( LoginActivity in this case ) that requires a dependency to be injected.",
                    "For that, you expose a function that takes as a parameter the object that requests injection.",
                    "This function tells Dagger that LoginActivity wants to access the graph and requests injection.",
                    "Dagger needs to satisfy all the dependencies that LoginActivity requires ( LoginViewModel with its own dependencies ).",
                    "If you have multiple classes that request injection, you have to specifically declare them all in the component with their exact type.",
                    "For example, if you had LoginActivity and RegistrationActivity requesting injection, you'd have two inject ( ) methods instead of a generic one covering both cases.",
                    "A generic inject ( ) method doesn't tell Dagger what needs to be provided.",
                    "The functions in the interface can have any name, but calling them inject ( ) when they receive the object to inject as a parameter is a convention in Dagger.",
                    "To inject an object in the activity, you'd use the appComponent defined in your application class and call the inject ( ) method, passing in an instance of the activity that requests injection.",
                    "When using activities, inject Dagger in the activity's onCreate ( ) method before calling super.onCreate ( ) to avoid issues with fragment restoration.",
                    "During the restore phase in super.onCreate ( ), an activity attaches fragments that might want to access activity bindings.",
                    "When using fragments, inject Dagger in the fragment's onAttach ( ) method.",
                    "In this case, it can be done before or after calling super.onAttach ( ).",
                    "Let's tell Dagger how to provide the rest of the dependencies to build the graph:",
                    "For this example, you're using the Retrofit networking library.",
                    "UserRemoteDataSource has a dependency on LoginRetrofitService.",
                    "However, the way to create an instance of LoginRetrofitService is different from what you've been doing until now.",
                    "It's not a class instantiation ; it's the result of calling Retrofit.Builder ( ) and passing in different parameters to configure the login service.",
                    "Apart from the @Inject annotation, there's another way to tell Dagger how to provide an instance of a class: the information inside Dagger modules.",
                    "A Dagger module is a class that is annotated with @Module.",
                    "There, you can define dependencies with the @Provides annotation.",
                    "Modules are a way to semantically encapsulate information on how to provide objects.",
                    "As you can see, you called the class NetworkModule to group the logic of providing objects related to networking.",
                    "If the application expands, you can also add how to provide an OkHttpClient here, or how to configure Gson or Moshi.",
                    "The dependencies of a @Provides method are the parameters of that method.",
                    "For the previous method, LoginRetrofitService can be provided with no dependencies because the method has no parameters.",
                    "If you had declared an OkHttpClient as a parameter, Dagger would need to provide an OkHttpClient instance from the graph to satisfy the dependencies of LoginRetrofitService.",
                    "In order for the Dagger graph to know about this module, you have to add it to the @Component interface as follows:",
                    "The recommended way to add types to the Dagger graph is by using constructor injection ( i.e. with the @Inject annotation on the constructor of the class ).",
                    "Sometimes, this is not possible and you have to use Dagger modules.",
                    "One example is when you want Dagger to use the result of a computation to determine how to create an instance of an object.",
                    "Whenever it has to provide an instance of that type, Dagger runs the code inside the @Provides method.",
                    "This is how the Dagger graph in the example looks right now:",
                    "Representation of the graph with LoginActivity being injected by Dagger",
                    "The entry point to the graph is LoginActivity.",
                    "Because LoginActivity injects LoginViewModel, Dagger builds a graph that knows how to provide an instance of LoginViewModel, and recursively, of its dependencies.",
                    "Dagger knows how to do this because of the @Inject annotation on the classes' constructor.",
                    "Inside the ApplicationComponent generated by Dagger, there's a factory-type method to get instances of all the classes it knows how to provide.",
                    "In this example, Dagger delegates to the NetworkModule included in ApplicationComponent to get an instance of LoginRetrofitService.",
                    "Scopes were mentioned on the Dagger basics page as a way to have a unique instance of a type in a component.",
                    "This is what is meant by scoping a type to the component's lifecycle.",
                    "Because you might want to use UserRepository in other features of the app and might not want to create a new object every time you need it, you can designate it as a unique instance for the whole app.",
                    "It is the same for LoginRetrofitService: it can be expensive to create, and you also want a unique instance of that object to be reused.",
                    "Creating an instance of UserRemoteDataSource is not that expensive, so scoping it to the component's lifecycle is not necessary.",
                    "@Singleton is the only scope annotation that comes with the javax.inject package.",
                    "You can use it to annotate ApplicationComponent and the objects you want to reuse across the whole application.",
                    "Take care not to introduce memory leaks when applying scopes to objects.",
                    "As long as the scoped component is in memory, the created object is in memory too.",
                    "Because ApplicationComponent is created when the app is launched ( in the application class ), it is destroyed when the app gets destroyed.",
                    "Thus, the unique instance of UserRepository always remains in memory until the application is destroyed.",
                    "If your login flow ( managed by a single LoginActivity ) consists of multiple fragments, you should reuse the same instance of LoginViewModel in all fragments.",
                    "@Singleton can not annotate LoginViewModel to reuse the instance for the following reasons:",
                    "The instance of LoginViewModel would persist in memory after the flow has finished.",
                    "You want a different instance of LoginViewModel for each login flow.",
                    "For example, if the user logs out, you want a different instance of LoginViewModel, rather than the same instance as when the user logged in for the first time.",
                    "To scope LoginViewModel to the lifecycle of LoginActivity you need to create a new component ( a new subgraph ) for the login flow and a new scope.",
                    "Let's create a graph specific to the login flow.",
                    "Now, LoginActivity should get injections from LoginComponent because it has a login-specific configuration.",
                    "This removes the responsibility to inject LoginActivity from the ApplicationComponent class.",
                    "LoginComponent must be able to access the objects from ApplicationComponent because LoginViewModel depends on UserRepository.",
                    "The way to tell Dagger that you want a new component to use part of another component is with Dagger subcomponents.",
                    "The new component must be a subcomponent of the component containing shared resources.",
                    "Subcomponents are components that inherit and extend the object graph of a parent component.",
                    "Thus, all objects provided in the parent component are provided in the subcomponent too.",
                    "In this way, an object from a subcomponent can depend on an object provided by the parent component.",
                    "To create instances of subcomponents, you need an instance of the parent component.",
                    "Therefore, the objects provided by the parent component to the subcomponent are still scoped to the parent component.",
                    "In the example, you must define LoginComponent as a subcomponent of ApplicationComponent.",
                    "To do this, annotate LoginComponent with @Subcomponent:",
                    "You also must define a subcomponent factory inside LoginComponent so that ApplicationComponent knows how to create instances of LoginComponent.",
                    "To tell Dagger that LoginComponent is a subcomponent of ApplicationComponent, you have to indicate it by:",
                    "Creating a new Dagger module ( e.g. SubcomponentsModule ) passing the subcomponent's class to the subcomponents attribute of the annotation.",
                    "Adding the new module ( i.e. SubcomponentsModule ) to ApplicationComponent:",
                    "Note that ApplicationComponent doesn't need to inject LoginActivity anymore because that responsibility now belongs to LoginComponent, so you can remove the inject ( ) method from ApplicationComponent.",
                    "Consumers of ApplicationComponent need to know how to create instances of LoginComponent.",
                    "The parent component must add a method in its interface to let consumers create instances of the subcomponent out of an instance of the parent component:",
                    "Expose the factory that creates instances of LoginComponentin the interface:",
                    "If you build the project, you can create instances of both ApplicationComponent and LoginComponent.",
                    "ApplicationComponent is attached to the lifecycle of the application because you want to use the same instance of the graph as long as the application is in memory.",
                    "What's the lifecycle of LoginComponent ?",
                    "One of the reasons why you needed LoginComponent is because you needed to share the same instance of the LoginViewModel between Login-related fragments.",
                    "But also, you want different instances of LoginViewModel whenever there's a new login flow.",
                    "LoginActivity is the right lifetime for LoginComponent: for every new activity, you need a new instance of LoginComponent and fragments that can use that instance of LoginComponent.",
                    "Because LoginComponent is attached to the LoginActivity lifecycle, you have to keep a reference to the component in the activity in the same way you kept the reference to the applicationComponent in the application class.",
                    "That way, fragments can access it.",
                    "Notice that the variable loginComponent is not annotated with @Inject because you're not expecting that variable to be provided by Dagger.",
                    "You can use the ApplicationComponent to get a reference to LoginComponent and then inject LoginActivity as follows:",
                    "LoginComponent is created in the activity's onCreate ( ) method, and it'll get implicitly destroyed when the activity gets destroyed.",
                    "The LoginComponent must always provide the same instance of LoginViewModel each time it's requested.",
                    "You can ensure this by creating a custom annotation scope and annotating both LoginComponent and LoginViewModel with it.",
                    "Note that you can not use the @Singleton annotation because it's already been used by the parent component and that'd make the object an application singleton ( unique instance for the whole app ).",
                    "You need to create a different annotation scope.",
                    "In this case, you could have called this scope @LoginScope but it's not a good practice.",
                    "The scope annotation's name should not be explicit to the purpose it fulfills.",
                    "Instead, it should be named depending on its lifetime because annotations can be reused by sibling components such as RegistrationComponent and SettingsComponent.",
                    "That's why you should call it @ActivityScope instead of @LoginScope.",
                    "Now, if you had two fragments that need LoginViewModel, both of them are provided with the same instance.",
                    "For example, if you have a LoginUsernameFragment and a LoginPasswordFragment they need to get injected by the LoginComponent:",
                    "The components access the instance of the component that lives in the LoginActivity object.",
                    "Example code for LoginUserNameFragment appears in the following code snippet:",
                    "And the same for LoginPasswordFragment:",
                    "Figure 3 shows how the Dagger graph looks with the new subcomponent.",
                    "The classes with a white dot ( UserRepository, LoginRetrofitService, and LoginViewModel ) are the ones that have a unique instance scoped to their respective components.",
                    "Representation of the graph you built for the Android app example",
                    "Let's break down the parts of the graph:",
                    "The NetworkModule ( and therefore LoginRetrofitService ) is included in ApplicationComponent because you specified it in the component.",
                    "UserRepository remains in ApplicationComponent because it's scoped to the ApplicationComponent.",
                    "If the project grows, you want to share the same instance across different features ( e.g. Registration ).",
                    "Because UserRepository is part of ApplicationComponent, its dependencies ( i.e. UserLocalDataSource and UserRemoteDataSource ) need to be in this component too in order to be able to provide instances of UserRepository.",
                    "LoginViewModel is included in LoginComponent because it's only required by the classes injected by LoginComponent.",
                    "LoginViewModel is not included in ApplicationComponent because no dependency in ApplicationComponent needs LoginViewModel.",
                    "Similarly, if you hadn't had scoped UserRepository to ApplicationComponent, Dagger would automatically have included UserRepository and its dependencies as part of LoginComponent because that is currently the only place UserRepository is used.",
                    "Apart from scoping objects to a different lifecycle, creating subcomponents is a good practice to encapsulate different parts of your application from each other.",
                    "Structuring your app to create different Dagger subgraphs depending on the flow of your app helps towards a more performant and scalable application in terms of memory and startup time.",
                    "When building the Dagger graph for your application:",
                    "When you create a component, you should consider what element is responsible for the lifetime of that component.",
                    "In this case, the application class was in charge of ApplicationComponent and LoginActivity in charge of LoginComponent.",
                    "Use scoping only when it makes sense.",
                    "Overusing scoping can have a negative effect on your app's runtime performance: the object is in memory as long as the component is in memory and getting a scoped object is more expensive.",
                    "When Dagger provides the object, it uses DoubleCheck locking instead of a factory-type provider.",
                    "One of the benefits of using dependency injection frameworks like Dagger is that it makes testing your code easier.",
                    "You don't have to use Dagger for unit tests.",
                    "When testing a class that uses constructor injection, you don't need to use Dagger to instantiate that class.",
                    "You can directly call its constructor passing in fake or mock dependencies directly just as you would if they weren't annotated.",
                    "For example, when testing LoginViewModel:",
                    "For integration tests, a good practice is to create a TestApplicationComponent meant for testing.",
                    "Production and testing use a different component configuration.",
                    "This requires more up-front design of the modules in your application.",
                    "The testing component extends the production component and installs a different set of modules.",
                    "FakeNetworkModule has a fake implementation of the original NetworkModule.",
                    "There you can provide fake instances or mocks of whatever you want to replace.",
                    "In your integration or end-to-end tests, you'd use a TestApplication that creates the TestApplicationComponent instead of an ApplicationComponent.",
                    "Then, this test application is used in a custom TestRunner that you'll use to run instrumentation tests.",
                    "For more information about this, check out the Using Dagger in your Android app codelab.",
                    "Dagger modules are a way to encapsulate how to provide objects in a semantic way.",
                    "You can include modules in components but you can also include modules inside other modules.",
                    "This is powerful, but can be easily misused.",
                    "Once a module has been added to either a component or another module, it's already in the Dagger graph ; Dagger can provide those objects in that component.",
                    "Before adding a module, check if that module is part of the Dagger graph already by checking if it's already added to the component or by compiling the project and seeing if Dagger can find the required dependencies for that module.",
                    "Good practice dictates that modules should only be declared once in a component ( outside of specific advanced Dagger use cases ).",
                    "Let's say you have your graph configured in this way.",
                    "ApplicationComponent includes Module1 and Module2 and Module1 includes ModuleX.",
                    "If now Module2 depends on classes provided by ModuleX.",
                    "A bad practice is including ModuleX in Module2 because ModuleX is included twice in the graph as seen in the following code snippet:",
                    "Instead, you should do one of the following:",
                    "Not refactoring in this way results in a lot of modules including each other without a clear sense of organization and making it more difficult to see where each dependency is coming from.",
                    "Good practice ( Option 1 ): ModuleX is declared once in the Dagger graph.",
                    "Good practice ( Option 2 ): Common dependencies from Module1 and Module2 in ModuleX are extracted out to a new module named ModuleXCommon that is included in the component.",
                    "Then two other modules named ModuleXWithModule1Dependencies and ModuleXWithModule2Dependencies are created with the dependencies that are specific to each module.",
                    "All modules are declared once in the Dagger graph.",
                    "Assisted injection is a DI pattern that is used to construct an object where some parameters may be provided by the DI framework and others must be passed in at creation time by the user.",
                    "In Android, this pattern is common in details screens where the id of the element to show is only known at runtime, not at compile time when Dagger generates the DI graph.",
                    "To learn more about assisted injection with Dagger, see the Dagger documentation.",
                    "If you haven't already, review the best practices section.",
                    "To see how to use Dagger in an Android app, see the Using Dagger in an Android app codelab.",
                    "Use constructor injection with @Inject to add types to the Dagger graph whenever it's possible.",
                    "When it's not: Use @Binds to tell Dagger which implementation an interface should have.",
                    "Use @Provides to tell Dagger how to provide classes that your project doesn't own.",
                    "Use @Binds to tell Dagger which implementation an interface should have.",
                    "You should only declare modules once in a component.",
                    "Name the scope annotations depending on the lifetime where the annotation is used.",
                    "Examples include @ApplicationScope, @LoggedUserScope, and @ActivityScope.",
                    "Adding the new module ( i.e. SubcomponentsModule ) to ApplicationComponent: Kotlin Java Note that ApplicationComponent doesn't need to inject LoginActivity anymore because that responsibility now belongs to LoginComponent, so you can remove the inject ( ) method from ApplicationComponent.",
                    "Expose the factory that creates instances of LoginComponentin the interface: Kotlin Java",
                    "When a type is marked with a scope annotation, it can only be used by components that are annotated with the same scope.",
                    "When a component is marked with a scope annotation, it can only provide types with that annotation or types that have no annotation.",
                    "A subcomponent can not use a scope annotation used by one of its parent components.",
                    "Refactor the modules and extract the common module out to the component.",
                    "Create a new module with the objects that both modules share and extract it out to the component.",
                    ""
                ],
                "title": "Using Dagger in Android apps \u00a0|\u00a0 Android Developers"
            }
        ],
        "git": [
            {
                "link": "https://github.com/square/retrofit/issues/573",
                "content": [
                    "Why custom annotations instead of JAX-RS ( JSR-311 ) ones ?",
                    "\u00b7 Issue # 573 \u00b7 square/retrofit \u00b7 GitHub",
                    "What was the design decision not to use the JAX-RS ( JSR-311 ) annotations and instead create custom ones ?",
                    "I would like to share the REST interfaces between my backend and Android frontend to not write them twice but this isn't possible due to the custom annotations or am I wrong ?",
                    "The text was updated successfully, but these errors were encountered:",
                    "Because JAX-RS annotations are specific to configuring a server, not a client.",
                    "There's all kinds of annotations which don't make sense in the context of a client ( @Consumes, @Produces, @Producer, @DefaultValue, @Context, etc. ), the regex-based path matching was something we didn't not want to support, none of the annotations deal with serialization, and we didn't want the ability to define @Path parts on types.",
                    "I spent a few days researching this over a year ago back before we had our v1 .0 and found all of the aforementioned problems.",
                    "Ultimately the annotations were designed with only the concerns of a server, not a client, in mind.",
                    "Note that JAX-RS 2.0 repurposed the annotations for use on client side, quite successfully.",
                    "That doesn't make them a good fit for Retrofit anyway though.",
                    "@simon - heinen did you found a way to reuse the interfaces ?",
                    "No but there are some possible ways: What you can do is create a version of retrofit where you modify the parser that it accepts both retrofit annotations and jax rs annotations which might be the best way or you add the retrofit annotations to your jax rs interfaces on the server side ( which I wouldn't recommend ; )",
                    "Using JAX-RS 1.1 annotations instead of Spring Cloud or Feign annotations",
                    ""
                ],
                "title": "Why custom annotations instead of JAX-RS ( JSR-311 ) ones ?"
            }
        ],
        "qa": [
            {
                "uid": "47760861",
                "link": "https://stackoverflow.com/questions/47760861",
                "title": "Retrofit 2 : Custom annotations for custom interceptor",
                "answers": [
                    {
                        "uid": 47762032,
                        "score": 1,
                        "text": [
                            "Interceptors are concepts that exist in OkHttp, Retrofit knows nothing about them.",
                            "What you need to do is have two OkHttp clients, with their respective instances of Retrofit.",
                            "Whether you need the authentication headers or not will decide which instance to inject."
                        ]
                    },
                    {
                        "uid": 48238342,
                        "score": 3,
                        "text": [
                            "I have similar requirement, what I found is Annotation can be read in LINK, LINK and LINK.",
                            "I also found two articles as examples for implementation on each way.",
                            "We'll use the gson converter -LRB- GsonConverterFactory -RRB- provided by Retrofit and modify it slightly to include a listener in GsonResponseBodyConverter.class which handles the http response parsing.",
                            "In GsonCacheableConverter, it overrides responseBodyConverter -LRB- -RRB- to persist response tagged with @Cacheable.",
                            "We read the annotation in the CallAdapter.Factory and when the request gets created in the CallAdapter, we will store some information for this kind of request within some map, to identify it later in some interceptor.",
                            "It uses a custom CallAdapter to get annotation @Authenticated, and put data into a map, which later parsed in the Interceptor.",
                            "I think requestBodyConverter -LRB- -RRB- and CallAdapter are closer to your requirement.",
                            "While if you do not insist on custom annotations, the easiest way for now in my opinion is to add custom header to the api interface, then read and remove it in the interceptor.",
                            "That is, adding @Headers -LRB- `` needauth: 1'' -RRB- to your services, and using chain.request -LRB- -RRB-.",
                            "header -LRB- `` needauth'' -RRB- to get the value.",
                            "Example: LINK."
                        ]
                    },
                    {
                        "uid": 62033263,
                        "score": 7,
                        "text": [
                            "Since the version of Retrofit 2.6.0, you can get the annotations in OkHttp Interceptor using the tag field like this:",
                            "Then inside of the interceptor, you can verify if the request is annotated or no.",
                            "Retrofit Changelog:",
                            "New: @Tag parameter annotation for setting tags on the underlying OkHttp Request object.",
                            "These can be read in CallAdapters or OkHttp Interceptors for tracing, analytics, varying behavior, and more.",
                            "LINK"
                        ]
                    },
                    {
                        "uid": 65242180,
                        "score": 0,
                        "text": [
                            "Based on LINK.",
                            "Did try to comment there but it looks too ugly because don't know how to make multiline.",
                            "I'm using as extension function:",
                            "fun < T: Annotation > Request.getCustomAnnotation -LRB- annotationClass: Class <T> -RRB-: T ?",
                            "= this.tag -LRB- Invocation:: class.java -RRB- ?",
                            ".",
                            "method -LRB- -RRB- ?",
                            ".",
                            "getAnnotation -LRB- annotationClass -RRB-",
                            "And you can use then like that:",
                            "request.getCustomAnnotation -LRB- YourAnnotation:: class.java -RRB-"
                        ]
                    }
                ],
                "tags": [
                    "android",
                    "retrofit2",
                    "interceptor",
                    "okhttp3"
                ]
            }
        ],
        "other": [
            {
                "link": "https://medium.com/@andretietz/custom-annotations-with-retrofit-2-8701ca7ce102",
                "type": "misc",
                "content": [
                    "Get startedOpen in appAndr\u00e9 Tietz224 FollowersAboutFollowSign inGet startedFollow224 FollowersAboutGet startedOpen in appCustom Annotations with Retrofit 2Andr\u00e9 TietzMay 30, 2016 \u00b7 5 min readIn some cases it would be nice to have custom annotation support in retrofit2.",
                    "A year ago I started to write a library in which I needed this feature.",
                    "In this article I will explain how to achieve and implement this.UPDATE: There's an updated and more detailed version of this article using Kotlin: Why do you need custom annotations?I guess in most cases you don't need to use custom annotations, but interceptors.",
                    "Since retrofit2 is based on okhttp, you can use interceptors ( in retrofit 1.X this was supported by retrofit itself, too ).",
                    "But what does it do ?",
                    "Well, basically every request you call ( using retrofit2 or plain okhttp ) calls all setup interceptors before executing requests.",
                    "The Interceptor is an interface which contains only one method to implement, called ( surprise ^ ^ ) intercept, which get's an object of Chain to proceed.How to use Interceptor?You can use Chain to executeor modify request and executethe next upcoming request.This setup applies for ALL requests that run with the okhttp client in which you setup these interceptors.Well, sometimes this is not enough, especially when you have runtime requirements for the modifications of the request.Why did I came up with this?Last year at droidcon Berlin I was thinking about a solution how to combine the android account manager and retrofit ( 1.9 back in the time ).",
                    "Most of the requests are authenticated requests, meaning that they need to contain some kind of authentication token in the header.",
                    "One would say now: Well, just use interceptors for this and add it to the header.I wanted to move this a step further.",
                    "What if there are multiple different Token-Types ( i.e. one for read-only, others for administration ) ?",
                    "What if the user is not logged in yet ?",
                    "What if the token is not valid anymore ?",
                    "What if the token can be refreshed?However, I decided to write an annotation that covers all this cases, so that the developer only needs to concentrate on defining the request itself, instead of handling all these cases in probably each case of a request.",
                    "So in the end I wanted to add annotations like thiswhich does the following: Check if there is a user for my given account typeIf not: open LoginIf there are multiple: let the user choose which one to usecheck if the account has an existent authentication tokenIf not: open LoginAdd the Token to the requestCall the requestCheck the result for 401 ( this usually happens when the token expires ) If so, search for a refresh token and try to refresh.",
                    "Continue with step 2If there's no refresh token: open LoginThe Library is called retroauth ( since it's an authentication library based on retrofit ) and you can find the current snapshot that supports retrofit2 on the jcenter snapshot repository.Implement custom annotationsI will show you how I achieved this using retrofit2.Defining the annotationWell, I guess this is the easiest part, just define your annotation as you like it.",
                    "In my case I needed an annotation that can take some arguments, such as Account-Type and Token-Type.",
                    "To make this as generic as possible, I decided to use a String arrayThe ideaSince we're not able to intercept the request creation to modify it there ( a couple of months ago, I created a PR on retrofit2 to do so, but it got declined and moved to some point in the future ), we have to do a workaround.",
                    "We read the annotation in the CallAdapter.Factory and when the request gets created in the CallAdapter, we will store some information for this kind of request within some map, to identify it later in some interceptor.So we need some map that can store a request identifier and some information.",
                    "As an identifier I chose an Integer and the information-part should be covered by a String just for simplicity.Additionally we need an Interceptor that reads this map and applies modifications on the request.Other than that, a wrapping CallAdapter is required.",
                    "This CallAdapter reads the freshly created request and creates an identifier, which will be read in the previously created Interceptor, when the request is executed.Implement itSo first we need a CallAdapter that wraps an actual CallAdapter and adds the additional functionality of identifying the request later.The Constructor arguments are the actual CallAdapter, the request identifier map described earlier.",
                    "In case of retroauth, I used for Android some kind of token type, that includes the account and the token type.",
                    "In the example we'll use a simple String.Now we need a factory to create this kind of CallAdapters.This Factory takes a list of CallAdapter factories ( we will come to that point later ) and the map we created before.When retrofit calls the get method, we check if the requested method contains an annotation.",
                    "If so, we return our wrapped CallAdapter, if not we return the CallAdapter found for the type.We still need the Interceptor, which could look like this: When intercepting the request we check if there was any information created for this particular request ( using the map ).",
                    "If so, we modify the request as we need it, if not we just execute it.Last but not least, we need the default CallAdapter.Factory from retrofit itself.",
                    "Retrofit provides a default Factory, which will be applied, when there's no other factories setup ( in case of using Call < ? >",
                    "It's created by retrofit itself and is package private.",
                    "To workaround this, you can create a package called retrofit2 in your src folder and create a helper class which hands out whatever you need.",
                    "For this case we only need the defaultCallAdapterFactory.Merge it all togetherSo at this point, we should have a custom CallAdapter.Factory that can create a custom CallAdapter, a custom Interceptor and the retrofit2 Helper class Retrofit2Platform for the default CallAdapter.Factory.So first, we create our request identifier map and a list of CallAdapter.Factory.",
                    "This list must contain at least the retrofit default adapter in order to work with your custom annotations.",
                    "Having those available we can create an instance of our custom CallAdapter.Factory, the Interceptor, the OkHttpClient and in the end the retrofit object.To not let the actual developer do this, I created a wrapper class in the library for the Retrofit.Builder, which takes care of this.SummaryIn this article we discovered how to implement a custom annotation for retrofit2.",
                    "There are still a couple of pain points.",
                    "Especially the identify method's I've been using may vary for your purpose.",
                    "Let's hope there will be a better solution soon.I'd like to hear your opinion and suggestions.For a full implementation have a look at the feature branch of my authentication library, which is still under development.",
                    "In particular the core project, which should work for java only, too.Here's the project: andretietz/retroauthretroauth - A library build on top of retrofit, for simple handling of authenticated requestsgithub.comLeave me a tweet, if you like.Andr\u00e9 Tietz ( @antietz ) | TwitterThe latest Tweets from Andr\u00e9 Tietz ( @antietz ).",
                    "work @moovel in #hamburg, loves #android.",
                    "Hamburg, Deutschlandtwitter.comAndr\u00e9 TietzAndroid DeveloperFollow276 1 Thanks to Marlon Bosse, Alberto Ballano, and Alexander Kreul.",
                    "276 276 1 AndroidAndroid App DevelopmentRetrofitMore from Andr\u00e9 TietzFollowAndroid DeveloperMore From MediumImplementing the Parcelable Interface in AndroidAnimesh RoySliding Radio Buttons in Android using KotlinAndr\u00e9 BorudFire Base with Kotlin MVVMChandraSaiMohan bhupathi in CodeXExploring Google Play App SigningJoe Birch in Google Developers ExpertsHow to Develop a Secure Android AppAmrit Lal SahuA Small Step to the Code, a BIG Step to Android UI -- Reusing LayoutsJohan Kovalsikoski in The StartupCreating a Kotlin Android Rotary KnobOren Geva in The StartupReact Native and Android Studio: Everything you need to get started in LinuxRomano Fenzo Flores in The StartupAboutHelpLegalGet the Medium app",
                    "Custom Annotations with Retrofit 2Andr\u00e9 TietzMay 30, 2016 \u00b7 5 min readIn some cases it would be nice to have custom annotation support in retrofit2.",
                    "In this article I will explain how to achieve and implement this.",
                    "Custom Annotations with Retrofit 2Andr\u00e9 TietzMay 30, 2016 \u00b7 5 min read",
                    "Andr\u00e9 TietzMay 30, 2016 \u00b7 5 min read",
                    "UPDATE: There's an updated and more detailed version of this article using Kotlin: Why do you need custom annotations?I guess in most cases you don't need to use custom annotations, but interceptors.",
                    "andretietz/retroauthretroauth - A library build on top of retrofit, for simple handling of authenticated requestsgithub.com",
                    "retroauth - A library build on top of retrofit, for simple handling of authenticated requests",
                    "Andr\u00e9 Tietz ( @antietz ) | TwitterThe latest Tweets from Andr\u00e9 Tietz ( @antietz ).",
                    ""
                ],
                "title": "Custom Annotations with Retrofit 2 | by Andr\u00e9 Tietz | Medium"
            }
        ]
    },
    "parsed": true
}