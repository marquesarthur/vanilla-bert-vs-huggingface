{
    "task": "Dagger 2 doesn't implement some of the component methods in Android project with custom annotation processor",
    "description": "Hi,\r\n\r\nwe've encountered a strange problem which I haven't seen anywhere:\r\n\r\n- We have a huge Android project where we inject presenters to our fragments using field injection. The corresponding component interface `MyFeatureComponent` has methods like `void inject(MyFeatureFragment fragment);` and the fragment is injected in its `onViewCreated()` callback like this: `MainApplication.get().getInjector().inject(this);` - nothing unusual here.\r\n- Thanks to MVP, our fragments are very dumb, so we generate some of their boilerplate with our custom annotation processor: We write abstract base fragment and the processor generates implementation which (among others) creates this line: `@Inject MyPresenter presenter;` and also the `...inject(this)` call.\r\n- And then it gets very strange: __for *some* of the fragments, Dagger doesn't generate `inject` method implementation__ (specified in `MyFeatureComponent` interface from which `MainComponent` inherits) in DaggerMainComponent, so the build fails with standard \"class is not abstract and does not implement....\" message. No errors from Dagger or our processor (our fragment class implementation is always generated correctly). However, Dagger *generates* members injector for the fragment, so in some way, it knows about the fragment implementation our annotation processor generated.\r\n- __If we write the whole fragment (including the field and the inject call) manually, Dagger always generates inject() implementation.__\r\n- __Or, if we move the `void inject(MyFeatureFragment fragment);` method up to `MainComponent`, Dagger also generates the implementation correctly.__\r\n- Our project is very huge and we haven't been able to find out why some of the inject() methods are generated and others are not, it seems completely random, but the non-generated methods are the same in each build. In some cases, Dagger doesn't even implement `inject()` for hand-written fragments if there are other generated fragments in the same package.\r\n- Tried to switch off incremental compilation, no change.\r\n- __Minimal working example here:__ [dagger-sample-repo.zip](https://github.com/google/dagger/files/643294/dagger-sample-repo.zip)\r\n- We are quite sure our annotation processor is OK regarding initialization, file writting, processing rounds etc. \r\n\r\nOur annotation processor is written entirely in Kotlin and parts of the app use Kotlin as well. Tried with Dagger 2.6 thru 2.8.\r\n\r\nWe're at our wits end here and have no better theory than that something is wrong with Dagger. Any ideas please? Thank you very much!",
    "type": "GIT",
    "link": "https://github.com/google/dagger/issues/524",
    "question_id": "524",
    "resources": {
        "api": [
            {
                "link": "https://developer.android.com/training/dependency-injection/dagger-android",
                "type": "android",
                "content": [
                    "The Dagger basics page explained how Dagger can help you automate dependency injection in your app.",
                    "With Dagger, you don't have to write tedious and error-prone boilerplate code.",
                    "To use Dagger in your project, add these dependencies to your application in your build.gradle file.",
                    "You can find the latest version of Dagger in this GitHub project.",
                    "Consider an example Android app with the dependency graph from Figure 1.",
                    "Dependency graph of the example code",
                    "In Android, you usually create a Dagger graph that lives in your application class because you want an instance of the graph to be in memory as long as the app is running.",
                    "In this way, the graph is attached to the app lifecycle.",
                    "In some cases, you might also want to have the application context available in the graph.",
                    "For that, you would also need the graph to be in the application class.",
                    "One advantage of this approach is that the graph is available to other Android framework classes.",
                    "Additionally, it simplifies testing by allowing you to use a custom application class in tests.",
                    "Because the interface that generates the graph is annotated with @Component, you can call it ApplicationComponent or ApplicationGraph.",
                    "You usually keep an instance of that component in your custom application class and call it every time you need the application graph, as shown in the following code snippet:",
                    "Because certain Android framework classes such as activities and fragments are instantiated by the system, Dagger can't create them for you.",
                    "For activities specifically, any initialization code needs to go into the onCreate ( ) method.",
                    "That means you can not use the @Inject annotation in the constructor of the class ( constructor injection ) as you did in the previous examples.",
                    "Instead, you have to use field injection.",
                    "Instead of creating the dependencies an activity requires in the onCreate ( ) method, you want Dagger to populate those dependencies for you.",
                    "For field injection, you instead apply the @Inject annotation to the fields that you want to get from the Dagger graph.",
                    "For simplicity, LoginViewModel is not an Android Architecture Components ViewModel ; it's just a regular class that acts as a ViewModel.",
                    "For more information about how to inject these classes, check out the code in the official Android Blueprints Dagger implementation, in the dev-dagger branch.",
                    "One of the considerations with Dagger is that injected fields can not be private.",
                    "They need to have at least package-private visibility like in the preceding code.",
                    "Dagger needs to know that LoginActivity has to access the graph in order to provide the ViewModel it requires.",
                    "In the Dagger basics page, you used the @Component interface to get objects from the graph by exposing functions with the return type of what you want to get from the graph.",
                    "In this case, you need to tell Dagger about an object ( LoginActivity in this case ) that requires a dependency to be injected.",
                    "For that, you expose a function that takes as a parameter the object that requests injection.",
                    "This function tells Dagger that LoginActivity wants to access the graph and requests injection.",
                    "Dagger needs to satisfy all the dependencies that LoginActivity requires ( LoginViewModel with its own dependencies ).",
                    "If you have multiple classes that request injection, you have to specifically declare them all in the component with their exact type.",
                    "For example, if you had LoginActivity and RegistrationActivity requesting injection, you'd have two inject ( ) methods instead of a generic one covering both cases.",
                    "A generic inject ( ) method doesn't tell Dagger what needs to be provided.",
                    "The functions in the interface can have any name, but calling them inject ( ) when they receive the object to inject as a parameter is a convention in Dagger.",
                    "To inject an object in the activity, you'd use the appComponent defined in your application class and call the inject ( ) method, passing in an instance of the activity that requests injection.",
                    "When using activities, inject Dagger in the activity's onCreate ( ) method before calling super.onCreate ( ) to avoid issues with fragment restoration.",
                    "During the restore phase in super.onCreate ( ), an activity attaches fragments that might want to access activity bindings.",
                    "When using fragments, inject Dagger in the fragment's onAttach ( ) method.",
                    "In this case, it can be done before or after calling super.onAttach ( ).",
                    "Let's tell Dagger how to provide the rest of the dependencies to build the graph:",
                    "For this example, you're using the Retrofit networking library.",
                    "UserRemoteDataSource has a dependency on LoginRetrofitService.",
                    "However, the way to create an instance of LoginRetrofitService is different from what you've been doing until now.",
                    "It's not a class instantiation ; it's the result of calling Retrofit.Builder ( ) and passing in different parameters to configure the login service.",
                    "Apart from the @Inject annotation, there's another way to tell Dagger how to provide an instance of a class: the information inside Dagger modules.",
                    "A Dagger module is a class that is annotated with @Module.",
                    "There, you can define dependencies with the @Provides annotation.",
                    "Modules are a way to semantically encapsulate information on how to provide objects.",
                    "As you can see, you called the class NetworkModule to group the logic of providing objects related to networking.",
                    "If the application expands, you can also add how to provide an OkHttpClient here, or how to configure Gson or Moshi.",
                    "The dependencies of a @Provides method are the parameters of that method.",
                    "For the previous method, LoginRetrofitService can be provided with no dependencies because the method has no parameters.",
                    "If you had declared an OkHttpClient as a parameter, Dagger would need to provide an OkHttpClient instance from the graph to satisfy the dependencies of LoginRetrofitService.",
                    "In order for the Dagger graph to know about this module, you have to add it to the @Component interface as follows:",
                    "The recommended way to add types to the Dagger graph is by using constructor injection ( i.e. with the @Inject annotation on the constructor of the class ).",
                    "Sometimes, this is not possible and you have to use Dagger modules.",
                    "One example is when you want Dagger to use the result of a computation to determine how to create an instance of an object.",
                    "Whenever it has to provide an instance of that type, Dagger runs the code inside the @Provides method.",
                    "This is how the Dagger graph in the example looks right now:",
                    "Representation of the graph with LoginActivity being injected by Dagger",
                    "The entry point to the graph is LoginActivity.",
                    "Because LoginActivity injects LoginViewModel, Dagger builds a graph that knows how to provide an instance of LoginViewModel, and recursively, of its dependencies.",
                    "Dagger knows how to do this because of the @Inject annotation on the classes' constructor.",
                    "Inside the ApplicationComponent generated by Dagger, there's a factory-type method to get instances of all the classes it knows how to provide.",
                    "In this example, Dagger delegates to the NetworkModule included in ApplicationComponent to get an instance of LoginRetrofitService.",
                    "Scopes were mentioned on the Dagger basics page as a way to have a unique instance of a type in a component.",
                    "This is what is meant by scoping a type to the component's lifecycle.",
                    "Because you might want to use UserRepository in other features of the app and might not want to create a new object every time you need it, you can designate it as a unique instance for the whole app.",
                    "It is the same for LoginRetrofitService: it can be expensive to create, and you also want a unique instance of that object to be reused.",
                    "Creating an instance of UserRemoteDataSource is not that expensive, so scoping it to the component's lifecycle is not necessary.",
                    "@Singleton is the only scope annotation that comes with the javax.inject package.",
                    "You can use it to annotate ApplicationComponent and the objects you want to reuse across the whole application.",
                    "Take care not to introduce memory leaks when applying scopes to objects.",
                    "As long as the scoped component is in memory, the created object is in memory too.",
                    "Because ApplicationComponent is created when the app is launched ( in the application class ), it is destroyed when the app gets destroyed.",
                    "Thus, the unique instance of UserRepository always remains in memory until the application is destroyed.",
                    "If your login flow ( managed by a single LoginActivity ) consists of multiple fragments, you should reuse the same instance of LoginViewModel in all fragments.",
                    "@Singleton can not annotate LoginViewModel to reuse the instance for the following reasons:",
                    "The instance of LoginViewModel would persist in memory after the flow has finished.",
                    "You want a different instance of LoginViewModel for each login flow.",
                    "For example, if the user logs out, you want a different instance of LoginViewModel, rather than the same instance as when the user logged in for the first time.",
                    "To scope LoginViewModel to the lifecycle of LoginActivity you need to create a new component ( a new subgraph ) for the login flow and a new scope.",
                    "Let's create a graph specific to the login flow.",
                    "Now, LoginActivity should get injections from LoginComponent because it has a login-specific configuration.",
                    "This removes the responsibility to inject LoginActivity from the ApplicationComponent class.",
                    "LoginComponent must be able to access the objects from ApplicationComponent because LoginViewModel depends on UserRepository.",
                    "The way to tell Dagger that you want a new component to use part of another component is with Dagger subcomponents.",
                    "The new component must be a subcomponent of the component containing shared resources.",
                    "Subcomponents are components that inherit and extend the object graph of a parent component.",
                    "Thus, all objects provided in the parent component are provided in the subcomponent too.",
                    "In this way, an object from a subcomponent can depend on an object provided by the parent component.",
                    "To create instances of subcomponents, you need an instance of the parent component.",
                    "Therefore, the objects provided by the parent component to the subcomponent are still scoped to the parent component.",
                    "In the example, you must define LoginComponent as a subcomponent of ApplicationComponent.",
                    "To do this, annotate LoginComponent with @Subcomponent:",
                    "You also must define a subcomponent factory inside LoginComponent so that ApplicationComponent knows how to create instances of LoginComponent.",
                    "To tell Dagger that LoginComponent is a subcomponent of ApplicationComponent, you have to indicate it by:",
                    "Creating a new Dagger module ( e.g. SubcomponentsModule ) passing the subcomponent's class to the subcomponents attribute of the annotation.",
                    "Adding the new module ( i.e. SubcomponentsModule ) to ApplicationComponent:",
                    "Note that ApplicationComponent doesn't need to inject LoginActivity anymore because that responsibility now belongs to LoginComponent, so you can remove the inject ( ) method from ApplicationComponent.",
                    "Consumers of ApplicationComponent need to know how to create instances of LoginComponent.",
                    "The parent component must add a method in its interface to let consumers create instances of the subcomponent out of an instance of the parent component:",
                    "Expose the factory that creates instances of LoginComponentin the interface:",
                    "If you build the project, you can create instances of both ApplicationComponent and LoginComponent.",
                    "ApplicationComponent is attached to the lifecycle of the application because you want to use the same instance of the graph as long as the application is in memory.",
                    "What's the lifecycle of LoginComponent ?",
                    "One of the reasons why you needed LoginComponent is because you needed to share the same instance of the LoginViewModel between Login-related fragments.",
                    "But also, you want different instances of LoginViewModel whenever there's a new login flow.",
                    "LoginActivity is the right lifetime for LoginComponent: for every new activity, you need a new instance of LoginComponent and fragments that can use that instance of LoginComponent.",
                    "Because LoginComponent is attached to the LoginActivity lifecycle, you have to keep a reference to the component in the activity in the same way you kept the reference to the applicationComponent in the application class.",
                    "That way, fragments can access it.",
                    "Notice that the variable loginComponent is not annotated with @Inject because you're not expecting that variable to be provided by Dagger.",
                    "You can use the ApplicationComponent to get a reference to LoginComponent and then inject LoginActivity as follows:",
                    "LoginComponent is created in the activity's onCreate ( ) method, and it'll get implicitly destroyed when the activity gets destroyed.",
                    "The LoginComponent must always provide the same instance of LoginViewModel each time it's requested.",
                    "You can ensure this by creating a custom annotation scope and annotating both LoginComponent and LoginViewModel with it.",
                    "Note that you can not use the @Singleton annotation because it's already been used by the parent component and that'd make the object an application singleton ( unique instance for the whole app ).",
                    "You need to create a different annotation scope.",
                    "In this case, you could have called this scope @LoginScope but it's not a good practice.",
                    "The scope annotation's name should not be explicit to the purpose it fulfills.",
                    "Instead, it should be named depending on its lifetime because annotations can be reused by sibling components such as RegistrationComponent and SettingsComponent.",
                    "That's why you should call it @ActivityScope instead of @LoginScope.",
                    "Now, if you had two fragments that need LoginViewModel, both of them are provided with the same instance.",
                    "For example, if you have a LoginUsernameFragment and a LoginPasswordFragment they need to get injected by the LoginComponent:",
                    "The components access the instance of the component that lives in the LoginActivity object.",
                    "Example code for LoginUserNameFragment appears in the following code snippet:",
                    "And the same for LoginPasswordFragment:",
                    "Figure 3 shows how the Dagger graph looks with the new subcomponent.",
                    "The classes with a white dot ( UserRepository, LoginRetrofitService, and LoginViewModel ) are the ones that have a unique instance scoped to their respective components.",
                    "Representation of the graph you built for the Android app example",
                    "Let's break down the parts of the graph:",
                    "The NetworkModule ( and therefore LoginRetrofitService ) is included in ApplicationComponent because you specified it in the component.",
                    "UserRepository remains in ApplicationComponent because it's scoped to the ApplicationComponent.",
                    "If the project grows, you want to share the same instance across different features ( e.g. Registration ).",
                    "Because UserRepository is part of ApplicationComponent, its dependencies ( i.e. UserLocalDataSource and UserRemoteDataSource ) need to be in this component too in order to be able to provide instances of UserRepository.",
                    "LoginViewModel is included in LoginComponent because it's only required by the classes injected by LoginComponent.",
                    "LoginViewModel is not included in ApplicationComponent because no dependency in ApplicationComponent needs LoginViewModel.",
                    "Similarly, if you hadn't had scoped UserRepository to ApplicationComponent, Dagger would automatically have included UserRepository and its dependencies as part of LoginComponent because that is currently the only place UserRepository is used.",
                    "Apart from scoping objects to a different lifecycle, creating subcomponents is a good practice to encapsulate different parts of your application from each other.",
                    "Structuring your app to create different Dagger subgraphs depending on the flow of your app helps towards a more performant and scalable application in terms of memory and startup time.",
                    "When building the Dagger graph for your application:",
                    "When you create a component, you should consider what element is responsible for the lifetime of that component.",
                    "In this case, the application class was in charge of ApplicationComponent and LoginActivity in charge of LoginComponent.",
                    "Use scoping only when it makes sense.",
                    "Overusing scoping can have a negative effect on your app's runtime performance: the object is in memory as long as the component is in memory and getting a scoped object is more expensive.",
                    "When Dagger provides the object, it uses DoubleCheck locking instead of a factory-type provider.",
                    "One of the benefits of using dependency injection frameworks like Dagger is that it makes testing your code easier.",
                    "You don't have to use Dagger for unit tests.",
                    "When testing a class that uses constructor injection, you don't need to use Dagger to instantiate that class.",
                    "You can directly call its constructor passing in fake or mock dependencies directly just as you would if they weren't annotated.",
                    "For example, when testing LoginViewModel:",
                    "For integration tests, a good practice is to create a TestApplicationComponent meant for testing.",
                    "Production and testing use a different component configuration.",
                    "This requires more up-front design of the modules in your application.",
                    "The testing component extends the production component and installs a different set of modules.",
                    "FakeNetworkModule has a fake implementation of the original NetworkModule.",
                    "There you can provide fake instances or mocks of whatever you want to replace.",
                    "In your integration or end-to-end tests, you'd use a TestApplication that creates the TestApplicationComponent instead of an ApplicationComponent.",
                    "Then, this test application is used in a custom TestRunner that you'll use to run instrumentation tests.",
                    "For more information about this, check out the Using Dagger in your Android app codelab.",
                    "Dagger modules are a way to encapsulate how to provide objects in a semantic way.",
                    "You can include modules in components but you can also include modules inside other modules.",
                    "This is powerful, but can be easily misused.",
                    "Once a module has been added to either a component or another module, it's already in the Dagger graph ; Dagger can provide those objects in that component.",
                    "Before adding a module, check if that module is part of the Dagger graph already by checking if it's already added to the component or by compiling the project and seeing if Dagger can find the required dependencies for that module.",
                    "Good practice dictates that modules should only be declared once in a component ( outside of specific advanced Dagger use cases ).",
                    "Let's say you have your graph configured in this way.",
                    "ApplicationComponent includes Module1 and Module2 and Module1 includes ModuleX.",
                    "If now Module2 depends on classes provided by ModuleX.",
                    "A bad practice is including ModuleX in Module2 because ModuleX is included twice in the graph as seen in the following code snippet:",
                    "Instead, you should do one of the following:",
                    "Not refactoring in this way results in a lot of modules including each other without a clear sense of organization and making it more difficult to see where each dependency is coming from.",
                    "Good practice ( Option 1 ): ModuleX is declared once in the Dagger graph.",
                    "Good practice ( Option 2 ): Common dependencies from Module1 and Module2 in ModuleX are extracted out to a new module named ModuleXCommon that is included in the component.",
                    "Then two other modules named ModuleXWithModule1Dependencies and ModuleXWithModule2Dependencies are created with the dependencies that are specific to each module.",
                    "All modules are declared once in the Dagger graph.",
                    "Assisted injection is a DI pattern that is used to construct an object where some parameters may be provided by the DI framework and others must be passed in at creation time by the user.",
                    "In Android, this pattern is common in details screens where the id of the element to show is only known at runtime, not at compile time when Dagger generates the DI graph.",
                    "To learn more about assisted injection with Dagger, see the Dagger documentation.",
                    "If you haven't already, review the best practices section.",
                    "To see how to use Dagger in an Android app, see the Using Dagger in an Android app codelab.",
                    "Use constructor injection with @Inject to add types to the Dagger graph whenever it's possible.",
                    "When it's not: Use @Binds to tell Dagger which implementation an interface should have.",
                    "Use @Provides to tell Dagger how to provide classes that your project doesn't own.",
                    "Use @Binds to tell Dagger which implementation an interface should have.",
                    "You should only declare modules once in a component.",
                    "Name the scope annotations depending on the lifetime where the annotation is used.",
                    "Examples include @ApplicationScope, @LoggedUserScope, and @ActivityScope.",
                    "Adding the new module ( i.e. SubcomponentsModule ) to ApplicationComponent: Kotlin Java Note that ApplicationComponent doesn't need to inject LoginActivity anymore because that responsibility now belongs to LoginComponent, so you can remove the inject ( ) method from ApplicationComponent.",
                    "Expose the factory that creates instances of LoginComponentin the interface: Kotlin Java",
                    "When a type is marked with a scope annotation, it can only be used by components that are annotated with the same scope.",
                    "When a component is marked with a scope annotation, it can only provide types with that annotation or types that have no annotation.",
                    "A subcomponent can not use a scope annotation used by one of its parent components.",
                    "Refactor the modules and extract the common module out to the component.",
                    "Create a new module with the objects that both modules share and extract it out to the component.",
                    ""
                ],
                "title": "Using Dagger in Android apps \u00a0|\u00a0 Android Developers"
            }
        ],
        "git": [
            
        ],
        "qa": [
            {
                "uid": "57235136",
                "link": "https://stackoverflow.com/questions/57235136",
                "title": "Dagger can not find classes generated by other annotation processor",
                "answers": [
                    {
                        "uid": 57320353,
                        "score": 0,
                        "text": [
                            "There may be a more elegant way to solve this, but the simplest and most reliable solution is to do two passes with javac -- once to run just your annotation processor, and the second to do everything it normally does.",
                            "The javac LINK specifies two options which should help you out.",
                            "- proc: -LCB- none, only -RCB-",
                            "Controls whether annotation processing and/or compilation is done.",
                            "- proc: none means that compilation takes place without annotation processing.",
                            "- proc: only means that only annotation processing is done, without any subsequent compilation.",
                            "- processor class1 -LSB-, class2, class3 ... -RSB-",
                            "Names of the annotation processors to run.",
                            "This bypasses the default discovery process.",
                            "The first pass -LRB- to run only your own annotation processor -RRB- is",
                            "and the second pass -LRB- a regular build -RRB- is",
                            "If you're using something like Ant or Maven, you should be able to update the build instructions to have two compiler passes with only a minimal amount of effort.",
                            "Edit: here's my attempt at Gradle instructions",
                            "I have no experience with Gradle, but it seems like you need to do something like this.",
                            "In your Gradle build script, you need to define the preprocessing task and add a dependency on your task to the javaCompile task."
                        ]
                    },
                    {
                        "uid": 57338381,
                        "score": 4,
                        "text": [
                            "New answer I have somehow missed that you are using kapt.",
                            "Kapt can process your classes, even without full qualified name -LRB- which is remarkable -RRB- if you add this to your build.gradle:",
                            "More info about this: LINK",
                            "Previous answer can be useful is someone has the same issue with annotationProcessor -LRB- apt -RRB- in gradle.",
                            "Short answer: use fully qualified name for ActivityInjectorModule:",
                            "Alternatively put both files in the same package.",
                            "Long answer: Dagger is an annotation processor, it runs before your code is compiled and -LRB- potentially -RRB- before your other annotation processor runs.",
                            "The sequence in which processors run is not defined.",
                            "Dagger annotation processor will process the TypeElement annotated with @dagger.",
                            "Component and it will try to find all modules including the `` ActivityInjectorModule.class''.",
                            "The thing is, ActivityInjectorModule might not have been generated yet.",
                            "Therefore `` ActivityInjectorModule'' will not have a package at this point.",
                            "Dagger will assume that ActivityInjectorModule resides in the same package as the Component class and will not add an import.",
                            "The usual workaround for this is to use full-qualified names for generated classes, if they are used by other annotation processors.",
                            "Sometimes it makes sense to move annotation processing to a difference gradle module, but I don't this that this is what you want."
                        ]
                    },
                    {
                        "uid": 57349757,
                        "score": 10,
                        "text": [
                            "Solution:",
                            "Explanation:",
                            "Javac annotation processor uses rounds instead of defining processors order.",
                            "So normally the simplified algorithm is like that:",
                            "LINK",
                            "Now a bit about kapt.",
                            "Kapt LINK to run annotation processors.",
                            "To make it possible, it runs kotlin compliler first to LINK and runs javac on them.",
                            "Currently kapt LINK, meaning it does not generate java stubs for kotlin classes, generated by annotation processors.",
                            "Note: javac still uses multiple rounds, it just can't pick up generated kotlin sources.",
                            "So, back to your question.",
                            "One possible option is to move your generated classes into a separate module like it's LINK.",
                            "But the easiest option is to generate java code directly and your generated java classes will be picked up by javac automatically, launching second round of annotation processing, where dagger will process them.",
                            "Just a few more notes:"
                        ]
                    }
                ],
                "tags": [
                    "java",
                    "android",
                    "dagger-2",
                    "annotation-processing",
                    "annotation-processor"
                ]
            }
        ],
        "other": [
            {
                "link": "https://medium.com/dvt-engineering/android-dagger-2-isnt-hard-97671ac15b07",
                "type": "misc",
                "content": [
                    "Sign inAndroidiOSUX/UIJava/Kotlin EnterpriseWebDevopsRecruitment We're Hiring = ) Android: Dagger 2 Isn't HardMike JohnstonFollowAug 6, 2019 \u00b7 7 min readPhoto by Yaroslav \u041aorshikov on UnsplashDuring my mission to learn, understand & implement Dagger 2 in Android apps, I've come across a surprising amount of confusing articles.",
                    "I had to spend time and energy just understanding their demo code before I even got to the interesting part.",
                    "I decided to attempt to present my findings in a ( hopefully ) simple and straightforward article.Thanks to Peter-John Welcome for reviewing this article!DaggerDagger is a fully static, compile-time dependency injection framework for both Java and Android.",
                    "It is an adaptation of ... dagger.devBut Why?Dagger 2 is a dependency injection ( DI ) framework.",
                    "It helps us by removing a lot of the boilerplate code we usually end up with when implementing DI ( such as factory classes and convenience constructors ).",
                    "Dagger will generate this code for us, so we don't have to see it or maintain it.Importantly, it is a compile-time DI framework.",
                    "This means that if we are trying to inject a dependency that isn't provided anywhere, compilation will fail ( rather than throwing a runtime exception ).",
                    "This allows us to catch potential issues earlier along in the development process, ultimately making our app more stable.Sample ProjectOur demo app will simply display a list of Pok\u00e9mon, as returned by the awesome Pok\u00e9API.",
                    "My code from the article can be found here.",
                    "These are the classes of interest: Activity: contains a RecyclerView to display Pok\u00e9mon dictated by its view modelView model: fetches Pok\u00e9mon from the repositoryRepository: fetches Pok\u00e9mon from the service once and stores them in the cache for subsequent callsService: makes a service call to fetch Pok\u00e9monCache: stores some Pok\u00e9mon in memoryOur goal is to have Dagger create all these objects for us ( except for the activity ; the Android system instantiates those ).",
                    "This means we don't need to have lots of factory classes and convenience constructors polluting the code.Note: the sample code is written in Kotlin, but everything is also possible in Java.MrBean355 / medium-dagger2You can't perform that action at this time.",
                    "You signed in with another tab or window.",
                    "You signed out in another tab or ... github.comDagger ComponentsDagger consists of a few key components: @Inject fields: tell Dagger to set these fields for us@Inject constructors: tell Dagger to use this constructor when trying to instantiate the class@Provides & @Binds methods: tell Dagger how to satisfy our dependencies@Module classes: contain the various @Provides & @Binds methods@Component class: binds all @Module classes into a dependency graphGradle DependenciesFirstly, we must add the Dagger dependencies to our project.",
                    "Let's add the following dependencies to our app-level build.gradle file ( see here for the latest version ): Note: for non-Kotlin projects, kapt must be replaced with annotationProcessor.",
                    "Initial SetupWhen first adding Dagger 2 support to the project, there are a few things we'll need to do: Custom Application ClassCreate a custom application class if there isn't one already ( remember to register it in the manifest ): Add this field to it: Make our application class implement HasAndroidInjector and return the field from this method: The DispatchingAndroidInjector that we're injecting into the application class above is just a class that facilitates injecting objects into Android-specific classes ( such as activities and fragments ).",
                    "It's used internally by Dagger whenever we ask it to inject such an Android component, like an activity.Component ClassCreate an interface like this: Important: build the project now.",
                    "Since Dagger 2 generates code behind the scenes, we'll need it to do its thing before continuing.Finally, in our custom application class we must instantiate the generated implementation of AppComponent.",
                    "The generated class's name is the interface's name prefixed with Dagger: Notice we're calling inject ( this ) in onCreate ( ) which is telling Dagger to inject the current instance of our application class.",
                    "This results in Dagger setting the androidInjector field to something ( doesn't matter what ) because it is annotated with @Inject.",
                    "Our one-time Dagger 2 setup is complete.",
                    "Now we can continue with providing the dependencies we care about.Providing DependenciesFirst up, we have to tell Dagger that we want our activity to be injectable.",
                    "That can be achieved by creating a @Module class with an abstract @ContributesAndroidInjector method: Note: the name of the method doesn't matter, and it is not called at runtime ; it's just for readability.",
                    "The important part is the return type.This new module needs to be registered in the Component as well: Now we can ask Dagger to inject our view model into the activity: Try to build the project.",
                    "It will fail because Dagger doesn't know how to instantiate the view model yet.",
                    "This can be rectified by annotating the view model's constructor with @Inject: This tells Dagger to use this constructor when it needs to instantiate the class.",
                    "We should now be able to build and run the project !",
                    "Although our app isn't really doing anything yet, we'll be able to navigate to the activity and the view model will be instantiated by Dagger.Let's update our app to actually fetch & display the Pok\u00e9mon list.",
                    "To start, we'll need to get the list of Pok\u00e9mon from the repository.",
                    "I'll add a constructor parameter of type PokemonRepository ( which is an interface ) to the view model: Notice that we've added the repository as a parameter of the constructor that we previously annotated with @Inject.",
                    "Dagger will try to instantiate each of the constructor parameters when instantiating the class.Compilation will now fail because Dagger doesn't know how to instantiate the PokemonRepository to pass to the view model's constructor.",
                    "Since it's an interface we can't simply add a @Inject - annotated constructor.",
                    "What we can do, however, is add another abstract method to our PokemonModule which `` binds'' the repository implementation to the interface: Again, the method name is not important.",
                    "The type of the parameter and the return type are what Dagger is looking at.",
                    "This basically says to Dagger: `` whenever someone injects the PokemonRepository interface, go and give them a PokemonRepositoryImpl instance''.",
                    "Now we need to add an @Inject - annotated constructor to PokemonRepositoryImpl so Dagger knows how to create it: Again, compilation will fail because Dagger doesn't know how to satisfy the service and cache constructor dependencies.",
                    "Since I'm using Retrofit to make service calls, the construction of a PokemonService object is a bit more complex.",
                    "This isn't an issue though, because we can create a concrete @Provides method to construct the Retrofit service: As usual, the method name doesn't matter ; the return type does.",
                    "This method will be called by Dagger whenever it needs to create a PokemonService object.",
                    "Other Dagger-provided dependencies can be added as parameters to @Provides methods.Finally, we need to specify how the cache object should be created.",
                    "Since it doesn't implement an interface, we can create an @Inject - annotated constructor as usual: The app will now compile successfully, but we will run into strange behaviour at runtime.",
                    "The `` bug'' is that Dagger will create a new PokemonCache each time it is injected, meaning data is never actually cached in between different activities.Fortunately, Dagger allows us to annotate the cache class as a singleton, meaning it will reuse the same instance throughout the app: Note: the @Component interface must also be annotated with @Singleton for this to work.Warning: there can still be multiple instances of the cache if the constructor is called manually.Warning: make sure you understand scoped bindings before going crazy with the @Singleton annotation.Now the app will compile & run with no problems, and we're using Dagger 2 to instantiate our dependencies.ConclusionDependency injection is definitely a must-have in every project ; that fact can't really be argued.",
                    "I strongly believe that Dagger 2 is worth using for DI in slightly larger projects, because it gets rid of a lot of ugly, boilerplate code.",
                    "We no longer need to write factory classes that instantiate the required dependencies.",
                    "Our code can be kept clean, concise and easy to maintain.DVT Software EngineeringMaking an impact in Software EngineeringFollow471 5 AndroidDagger 2KotlinDependency InjectionAndroid App Development471 claps471 claps5 Written byMike JohnstonFollowGamer and Android developer.FollowDVT Software EngineeringFollowMaking an impact in Software EngineeringFollowWritten byMike JohnstonFollowGamer and Android developer.DVT Software EngineeringFollowMaking an impact in Software EngineeringMore From MediumExploring how to provide your own backup-restore mechanism in your Android app.Spians LabsA Brief Intro to Dagger HiltKarlo Miguel in The StartupUnidirectional data-flow and the Zen of black box componentsZsolt Kocsi in Bumble TechSetting up Android Emulator in M1 MacSai Balaji in TechiepediaOAuth2 in Android -- Authorization Code FlowAlex Queudot in L+R EngineersAndroid w/o DIBob Dahlberg in The StartupHow to Convert Dagger-Android to HiltNemanja Stamenovic in The StartupA Brief Introduction to Flutter Version ManagementZubair Rehman in Embrace-ItLearn more.Medium is an open platform where 170 million readers come to find insightful and dynamic thinking.",
                    "Here, expert and undiscovered voices alike dive into the heart of any topic and bring new ideas to the surface.",
                    "Learn moreMake Medium yours.Follow the writers, publications, and topics that matter to you, and you'll see them on your homepage and in your inbox.",
                    "ExploreShare your thinking.If you have a story to tell, knowledge to share, or a perspective to offer -- welcome home.",
                    "It's easy and free to post your thinking on any topic.",
                    "Write on MediumAboutHelpLegalGet the Medium app",
                    "Android: Dagger 2 Isn't HardMike JohnstonFollowAug 6, 2019 \u00b7 7 min readPhoto by Yaroslav \u041aorshikov on UnsplashDuring my mission to learn, understand & implement Dagger 2 in Android apps, I've come across a surprising amount of confusing articles.",
                    "Our code can be kept clean, concise and easy to maintain.",
                    "You signed out in another tab or ... github.comDagger ComponentsDagger consists of a few key components: @Inject fields: tell Dagger to set these fields for us@Inject constructors: tell Dagger to use this constructor when trying to instantiate the class@Provides & @Binds methods: tell Dagger how to satisfy our dependencies@Module classes: contain the various @Provides & @Binds methods@Component class: binds all @Module classes into a dependency graph",
                    "Android: Dagger 2 Isn't HardMike JohnstonFollowAug 6, 2019 \u00b7 7 min read",
                    "Mike JohnstonFollowAug 6, 2019 \u00b7 7 min read",
                    "DaggerDagger is a fully static, compile-time dependency injection framework for both Java and Android.",
                    "It is an adaptation of ... dagger.dev",
                    "Dagger is a fully static, compile-time dependency injection framework for both Java and Android.",
                    "It is an adaptation of ...",
                    "MrBean355/medium-dagger 2You can't perform that action at this time.",
                    "You signed out in another tab or ... github.com",
                    "You can't perform that action at this time.",
                    "You signed out in another tab or ...",
                    "Gradle DependenciesFirstly, we must add the Dagger dependencies to our project.",
                    "Now we can continue with providing the dependencies we care about.",
                    "Providing DependenciesFirst up, we have to tell Dagger that we want our activity to be injectable.",
                    "DVT Software EngineeringMaking an impact in Software EngineeringFollow471 5",
                    "DVT Software EngineeringMaking an impact in Software EngineeringFollow",
                    "Making an impact in Software Engineering",
                    "AndroidDagger 2KotlinDependency InjectionAndroid App Development471 claps471 claps5 Written byMike JohnstonFollowGamer and Android developer.FollowDVT Software EngineeringFollowMaking an impact in Software EngineeringFollowWritten byMike JohnstonFollowGamer and Android developer.DVT Software EngineeringFollowMaking an impact in Software EngineeringMore From MediumExploring how to provide your own backup-restore mechanism in your Android app.Spians LabsA Brief Intro to Dagger HiltKarlo Miguel in The StartupUnidirectional data-flow and the Zen of black box componentsZsolt Kocsi in Bumble TechSetting up Android Emulator in M1 MacSai Balaji in TechiepediaOAuth2 in Android -- Authorization Code FlowAlex Queudot in L+R EngineersAndroid w/o DIBob Dahlberg in The StartupHow to Convert Dagger-Android to HiltNemanja Stamenovic in The StartupA Brief Introduction to Flutter Version ManagementZubair Rehman in Embrace-It",
                    ""
                ],
                "title": "Android: Dagger 2 Isn\u2019t Hard. Implementing Dagger 2 in Android apps\u2026 | by Mike Johnston | DVT Software Engineering | Medium"
            },
            {
                "link": "https://guides.codepath.com/android/dependency-injection-with-dagger-2",
                "type": "misc",
                "content": [
                    "For instance, a Twitter API client may be built using a networking library such as Retrofit.",
                    "To use this library, you might also need to add parsing libraries such as Gson.",
                    "In addition, classes that implement authentication or caching may require accessing shared preferences or other common storage, requiring instantiating them first and creating an inherent dependency chain.",
                    "If you're not familiar with Dependency Injection, watch this quick video.",
                    "Dagger 2 analyzes these dependencies for you and generates code to help wire them together.",
                    "While there are other Java dependency injection frameworks, many of them suffered limitations in relying on XML, required validating dependency issues at run-time, or incurred performance penalties during startup.",
                    "Dagger 2 relies purely on using Java annotation processors and compile-time checks to analyze and verify dependencies.",
                    "It is considered to be one of the most efficient dependency injection frameworks built to date.",
                    "Advantages Here is a list of other advantages for using Dagger 2:",
                    "Simplifies access to shared instances.",
                    "Just as the ButterKnife library makes it easier to define references to Views, event handlers, and resources, Dagger 2 provides a simple way to obtain references to shared instances.",
                    "For instance, once we declare in Dagger our singleton instances such as MyTwitterApiClient or SharedPreferences, we can declare fields with a simple @Inject annotation:",
                    "Easy configuration of complex dependencies.",
                    "There is an implicit order in which your objects are often created.",
                    "Dagger 2 walks through the dependency graph and generates code that is both easy to understand and trace, while also saving you from writing the large amount of boilerplate code you would normally need to write by hand to obtain references and pass them to other objects as dependencies.",
                    "It also helps simplify refactoring, since you can focus on what modules to build rather than focusing on the order in which they need to be created.",
                    "Easier unit and integration testing Because the dependency graph is created for us, we can easily swap out modules that make network responses and mock out this behavior.",
                    "Scoped instances Not only can you easily manage instances that can last the entire application lifecycle, you can also leverage Dagger 2 to define instances with shorter lifetimes ( i.e. bound to a user session, activity lifecycle, etc. ).",
                    "Setup Android Studio by default will not allow you to navigate to generated Dagger 2 code as legitimate classes because they are not normally added to the source path.",
                    "Adding the annotationProcessor plugin will add these files into the IDE classpath and enable you to have more visibility.",
                    "Make sure to upgrade to the latest Gradle version to use the annotationProcessor syntax:",
                    "If you are using Kotlin, then you should use the following setup:",
                    "Note that the compileOnly keyword refers to dependencies that are only needed at compilation.",
                    "Since Dagger 2 generates code that is used by your app at runtime, the implementation configuration should be used for the dagger libraries.",
                    "The Dagger compiler generates code that is used to create the dependency graph of the classes defined in your source code.",
                    "These classes are added to the IDE class path during compilation.",
                    "The annotationProcessor keyword, which is understood by the Android Gradle plugin, does not add these classes to the class path, they are used only for annotation processing, which prevents accidentally referencing them.",
                    "The simplest example is to show how to centralize all your singleton creation with Dagger 2.",
                    "Suppose you weren't using any type of dependency injection framework and wrote code in your Twitter client similar to the following:",
                    "Declare your singletons You need to define what objects should be included as part of the dependency chain by creating a Dagger 2 module.",
                    "For instance, if we wish to make a single Retrofit instance tied to the application lifecycle and available to all our activities and fragments, we first need to make Dagger aware that a Retrofit instance can be provided.",
                    "Because we wish to setup caching, we need an Application context.",
                    "Our first Dagger module, AppModule.java, will be used to provide this reference.",
                    "We will define a method annotated with @Provides that informs Dagger that this method is the constructor for the Application return type ( i.e., it is the method in charge of providing the instance of the Application class ):",
                    "We create a class called NetModule.java and annotate it with @Module to signal to Dagger to search within the available methods for possible instance providers.",
                    "The methods that will actually expose available return types should also be annotated with the @Provides annotation.",
                    "The @Singleton annotation also signals to the Dagger compiler that the instance should be created only once in the application.",
                    "In the following example, we are specifying SharedPreferences, Gson, Cache, OkHttpClient, and Retrofit as the return types that can be used as part of the dependency list.",
                    "Note that the method names ( i.e. provideGson ( ), provideRetrofit ( ), etc ) do not matter and can be named anything.",
                    "The return type annotated with a @Provides annotation is used to associate this instantiation with any other modules of the same type.",
                    "The @Singleton annotation is used to declare to Dagger that the provided object is to be only initialized only once during the entire lifecycle of the Component which uses that Module.",
                    "A Retrofit instance depends both on a Gson and OkHttpClient instance, so we can define another method within the same class that takes these two types.",
                    "The @Provides annotation and these two parameters in the method will cause Dagger to recognize that there is a dependency on Gson and OkHttpClient to build a Retrofit instance.",
                    "Define injection targets Dagger provides a way for the fields in your activities, fragments, or services to be assigned references simply by annotating the fields with an @Inject annotation and calling an inject ( ) method.",
                    "Calling inject ( ) will cause Dagger 2 to locate the singletons in the dependency graph to try to find a matching return type.",
                    "If it finds one, it assigns the references to the respective fields.",
                    "For instance, in the example below, it will attempt to find a provider that returns MyTwitterApiClient and a SharedPreferences type:",
                    "The injector class used in Dagger 2 is called a component.",
                    "It assigns references in our activities, services, or fragments to have access to singletons we earlier defined.",
                    "We will need to annotate this class with a @Component annotation.",
                    "Note that the activities, services, or fragments that are allowed to request the dependencies declared by the modules ( by means of the @Inject annotation ) should be declared in this class with individual inject ( ) methods:",
                    "Note that base classes are not sufficient as injection targets.",
                    "Dagger 2 relies on strongly typed classes, so you must specify explicitly which ones should be defined.",
                    "( There are suggestions to workaround the issue, but the code to do so may be more complicated to trace than simply defining them. )",
                    "Code generation An important aspect of Dagger 2 is that the library generates code for classes annotated with the @Component interface.",
                    "You can use a class prefixed with Dagger ( i.e. DaggerTwitterApiComponent.java ) that will be responsible for instantiating an instance of our dependency graph and using it to perform the injection work for fields annotated with @Inject.",
                    "Instantiating the component We should do all this work within a specialization of the Application class since these instances should be declared only once throughout the entire lifespan of the application:",
                    "Make sure to rebuild the project ( in Android Studio, select Build > Rebuild Project ) if you can not reference the Dagger component.",
                    "Because we are extending the default Application class with the class MyApp, we have to specify MyApp as the application name in the AndroidManifest.xml in order for it to be instantiated.",
                    "This way your app will launch MyApp to handle the initial instantiation.",
                    "Within our activity, we simply need to get access to these components and call inject ( ).",
                    "If we need two different objects of the same return type, we can use the @Named qualifier annotation.",
                    "You will define it both where you provide the singletons ( @Provides annotation ), and where you inject them ( @Inject annotations ):",
                    "Injection will also require these named annotations too:",
                    "@Named is a qualifier that is pre-defined by dagger, but you can create your own qualifier annotations as well:",
                    "In Dagger 2, you can define how components should be encapsulated by defining custom scopes.",
                    "For instance, you can create a scope that only lasts the duration of an activity or fragment lifecycle.",
                    "You can create a scope that maps only to a user authenticated session.",
                    "You can define any number of custom scope annotations in your application by declaring them as a public @interface:",
                    "Even though Dagger 2 does not rely on the annotation at runtime, keeping the RetentionPolicy at RUNTIME is useful in allowing you to inspect your modules later.",
                    "Dependent Components vs. Subcomponents Leveraging scopes allows us to create either dependent components or subcomponents.",
                    "The example above showed that we used the @Singleton annotation that lasted the entire lifecycle of the application.",
                    "We also relied on one major Dagger component.",
                    "If we wish to have multiple components that do not need to remain in memory all the time ( i.e. components that are tied to the lifecycle of an activity or fragment, or even tied to when a user is signed-in ), we can create dependent components or subcomponents.",
                    "In either case, each provide a way of encapsulating your code.",
                    "We'll see how to use both in the next section.",
                    "There are several considerations when using these approaches:",
                    "Dependent components require the parent component to explicitly list out what dependencies can be injected downstream, while subcomponents do not.",
                    "For parent components, you would need to expose to the downstream component by specifying the type and a method:",
                    "If you forget to add this line, you will likely see an error about an injection target missing.",
                    "Similar to how private/public variables are managed, using a parent component allows more explicit control and better encapsulation, but using subcomponents makes dependency injection easier to manage at the expense of less encapsulation.",
                    "Two dependent components can not share the same scope.",
                    "For instance, two components can not both be scoped as @Singleton.",
                    "This restriction is imposed because of reasons described here.",
                    "Dependent components need to define their own scope.",
                    "While Dagger 2 also enables the ability to create scoped instances, the responsibility rests on you to create and delete references that are consistent with the intended behavior.",
                    "Dagger 2 does not know anything about the underlying implementation.",
                    "See this Stack Overflow discussion for more details.",
                    "For instance, if we wish to use a component created for the entire lifecycle of a user session signed into the application, we can define our own UserScope interface:",
                    "Next, we define the parent component:",
                    "We can then define a child component:",
                    "Let's assume this GitHub module simply returns back an API interface to the GitHub API:",
                    "In order for this GitHubModule.java to get access to the Retrofit instance, we need explicitly define them in the upstream component.",
                    "If the downstream modules will be performing the injection, they should also be removed from the upstream components too:",
                    "The final step is to use the UserComponent to perform the instantiation.",
                    "This time, we first need to build the AppComponent and pass it into the constructor of the DaggerUserComponent builder:",
                    "See this example code for a working example.",
                    "Using subcomponents is another way to extend the object graph of a component.",
                    "Like components with dependencies, subcomponents have their own life-cycle and can be garbage collected when all references to the subcomponent are gone, and have the same scope restrictions.",
                    "One advantage in using this approach is that you do not need to define all the downstream components.",
                    "Another major difference is that subcomponents simply need to be declared in the parent component.",
                    "Here's an example of using a subcomponent for an activity.",
                    "We annotate the class with a custom scope and the @Subcomponent annotation:",
                    "The module that will be used is defined below:",
                    "Finally, in the parent component, we will define a factory method with the return value of the component and the dependencies needed to instantiate it:",
                    "In the above example, a new instance of the subcomponent will be created every time that the newMyActivitySubcomponent ( ) is called.",
                    "To use the submodule to inject an activity:",
                    "Subcomponent Builders Available starting in v2 .7",
                    "Subcomponent builders allow the creator of the subcomponent to be de-coupled from the parent component, by removing the need to have a subcomponent factory method declared on that parent component.",
                    "The subcomponent is declared as an inner interface in the subcomponent interface and it must include a build ( ) method which the return type matching the subcomponent.",
                    "It's convenient to declare a base interface with this method, like SubcomponentBuilder above.",
                    "This new builder must be added to the parent component graph using a `` binder'' module with a `` subcomponents'' parameter:",
                    "Once the builders are made available in the component graph, the activity can use it to create its subcomponent:",
                    "ProGuard Dagger 2 should work out of box without ProGuard, but if you start seeing library class dagger.producers.monitoring.internal.Monitors $ 1 extends or implements program class javax.inject.Provider, make sure your Gradle configuration uses the annotationProcessor declaration instead of provided.",
                    "If you are upgrading Dagger 2 versions ( i.e. from v2 .0 to v2 .5 ), some of the generated code has changed.",
                    "If you are incorporating Dagger code that was generated with older versions, you may see MemberInjector and actual and former argument lists different in length errors.",
                    "Make sure to clean the entire project and verify that you have upgraded all versions to use the consistent version of Dagger 2.",
                    "Dagger 2 Github Page Sample project using Dagger 2 Vince Mi's Codepath Meetup Dagger 2 Slides http://code.tutsplus.com/tutorials/dependency-injection-with-dagger-2-on-android--cms-23345 Jake Wharton's Devoxx Dagger 2 Slides Jake Wharton's Devoxx Dagger 2 Talk Dagger 2 Google Developers Talk Dagger 1 to Dagger 2 Tasting Dagger 2 on Android Dagger 2 Testing with Mockito",
                    "Snorkeling with Dagger 2 Dependency Injection in Java Component Dependency vs. Submodules in Dagger 2 Dagger 2 Component Scopes Test Advanced Dagger Talk Dagger 2 For Beginner Tutorial Dependency Injection with Dagger 2",
                    "Overview Many Android apps rely on instantiating objects that often require other dependencies.",
                    ""
                ],
                "title": "Dependency Injection with Dagger 2 | CodePath Android Cliffnotes"
            }
        ]
    },
    "parsed": true
}