{
  "session_uid": "Tarcisio",
  "type": "FROM_PARTICIPANT",
  "items": [
    {
      "id": "eye-gazing-tag-7",
      "tag": "SPAN",
      "text": "This is happening because FusedLocationProviderApi deprecated in a recent version of google play services.",
      "href": "java - Android LocationServices.FusedLocationApi deprecated - Stack Overflow"
    },
    {
      "id": "eye-gazing-tag-9",
      "tag": "SPAN",
      "text": "The official guide now suggests using FusedLocationProviderClient.",
      "href": "java - Android LocationServices.FusedLocationApi deprecated - Stack Overflow"
    },
    {
      "id": "eye-gazing-tag-10",
      "tag": "SPAN",
      "text": "You can find the detailed guide  here.",
      "href": "java - Android LocationServices.FusedLocationApi deprecated - Stack Overflow"
    },
    {
      "id": "eye-gazing-tag-14",
      "tag": "SPAN",
      "text": "Java",
      "href": "java - Android LocationServices.FusedLocationApi deprecated - Stack Overflow"
    },
    {
      "id": "uid-897",
      "tag": "PRE",
      "text": "FusedLocationProviderClient fusedLocationClient = LocationServices.getFusedLocationProviderClient(requireContext());\n",
      "href": "java - Android LocationServices.FusedLocationApi deprecated - Stack Overflow"
    },
    {
      "id": "uid-898",
      "tag": "CODE",
      "text": "FusedLocationProviderClient fusedLocationClient = LocationServices.getFusedLocationProviderClient(requireContext());\n",
      "href": "java - Android LocationServices.FusedLocationApi deprecated - Stack Overflow"
    },
    {
      "id": "uid-900",
      "tag": "PRE",
      "text": "fusedLocationClient.getLastLocation().addOnSuccessListener(requireActivity(), location -> {\n        if (location != null) {\n            // Logic to handle location object\n        } else {\n            // Handle null case or Request periodic location update https://developer.android.com/training/location/receive-location-updates\n        }\n    });\n",
      "href": "java - Android LocationServices.FusedLocationApi deprecated - Stack Overflow"
    },
    {
      "id": "uid-901",
      "tag": "CODE",
      "text": "fusedLocationClient.getLastLocation().addOnSuccessListener(requireActivity(), location -> {\n        if (location != null) {\n            // Logic to handle location object\n        } else {\n            // Handle null case or Request periodic location update https://developer.android.com/training/location/receive-location-updates\n        }\n    });\n",
      "href": "java - Android LocationServices.FusedLocationApi deprecated - Stack Overflow"
    },
    {
      "id": "uid-1060",
      "tag": "PRE",
      "text": "   // Better to use GoogleApiClient to show device location. I am using this way in my aap.\n\n    public class SuccessFragment extends Fragment{\n        private TextView txtLatitude, txtLongitude, txtAddress;\n        // private AddressResultReceiver mResultReceiver;\n        // removed here because cause wrong code when implemented and\n        // its not necessary like the author says\n\n        //Define fields for Google API Client\n        private FusedLocationProviderClient mFusedLocationClient;\n        private Location lastLocation;\n        private LocationRequest locationRequest;\n        private LocationCallback mLocationCallback;\n\n        private static final int REQUEST_PERMISSIONS_REQUEST_CODE = 14;\n\n        @Nullable\n        @Override\n        public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\n            View view = inflater.inflate(R.layout.fragment_location, container, false);\n\n            txtLatitude = (TextView) view.findViewById(R.id.txtLatitude);\n            txtLongitude = (TextView) view.findViewById(R.id.txtLongitude);\n            txtAddress = (TextView) view.findViewById(R.id.txtAddress);\n\n            // mResultReceiver = new AddressResultReceiver(null);\n            // cemented as above explained\n            try {\n                mFusedLocationClient = LocationServices.getFusedLocationProviderClient(getActivity());\n                mFusedLocationClient.getLastLocation()\n                        .addOnSuccessListener(getActivity(), new OnSuccessListener<Location>() {\n                            @Override\n                            public void onSuccess(Location location) {\n                                // Got last known location. In some rare situations this can be null.\n                                if (location != null) {\n                                    // Logic to handle location object\n                                    txtLatitude.setText(String.valueOf(location.getLatitude()));\n                                    txtLongitude.setText(String.valueOf(location.getLongitude()));\n                                    if (mResultReceiver != null)\n                                        txtAddress.setText(mResultReceiver.getAddress());\n                                }\n                            }\n                        });\n                locationRequest = LocationRequest.create();\n                locationRequest.setInterval(5000);\n                locationRequest.setFastestInterval(1000);\n                if (txtAddress.getText().toString().equals(\"\"))\n                    locationRequest.setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY);\n                else\n                    locationRequest.setPriority(LocationRequest.PRIORITY_BALANCED_POWER_ACCURACY);\n\n                mLocationCallback = new LocationCallback() {\n                    @Override\n                    public void onLocationResult(LocationResult locationResult) {\n                        for (Location location : locationResult.getLocations()) {\n                            // Update UI with location data\n                            txtLatitude.setText(String.valueOf(location.getLatitude()));\n                            txtLongitude.setText(String.valueOf(location.getLongitude()));\n                        }\n                    }\n\n                    ;\n                };\n            } catch (SecurityException ex) {\n                ex.printStackTrace();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return view;\n        }\n\n        @Override\n        public void onStart() {\n            super.onStart();\n\n            if (!checkPermissions()) {\n                startLocationUpdates();\n                requestPermissions();\n            } else {\n                getLastLocation();\n                startLocationUpdates();\n            }\n        }\n\n        @Override\n        public void onPause() {\n            stopLocationUpdates();\n            super.onPause();\n        }\n\n        /**\n         * Return the current state of the permissions needed.\n         */\n        private boolean checkPermissions() {\n            int permissionState = ActivityCompat.checkSelfPermission(getActivity(),\n                    Manifest.permission.ACCESS_COARSE_LOCATION);\n            return permissionState == PackageManager.PERMISSION_GRANTED;\n        }\n\n        private void startLocationPermissionRequest() {\n            ActivityCompat.requestPermissions(getActivity(),\n                    new String[]{Manifest.permission.ACCESS_COARSE_LOCATION},\n                    REQUEST_PERMISSIONS_REQUEST_CODE);\n        }\n\n\n        private void requestPermissions() {\n            boolean shouldProvideRationale =\n                    ActivityCompat.shouldShowRequestPermissionRationale(getActivity(),\n                            Manifest.permission.ACCESS_COARSE_LOCATION);\n\n            // Provide an additional rationale to the user. This would happen if the user denied the\n            // request previously, but didn't check the \"Don't ask again\" checkbox.\n            if (shouldProvideRationale) {\n                Log.i(TAG, \"Displaying permission rationale to provide additional context.\");\n\n                showSnackbar(R.string.permission_rationale, android.R.string.ok,\n                        new View.OnClickListener() {\n                            @Override\n                            public void onClick(View view) {\n                                // Request permission\n                                startLocationPermissionRequest();\n                            }\n                        });\n\n            } else {\n                Log.i(TAG, \"Requesting permission\");\n                // Request permission. It's possible this can be auto answered if device policy\n                // sets the permission in a given state or the user denied the permission\n                // previously and checked \"Never ask again\".\n                startLocationPermissionRequest();\n            }\n        }\n\n        /**\n         * Callback received when a permissions request has been completed.\n         */\n        @Override\n        public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,\n                                               @NonNull int[] grantResults) {\n            Log.i(TAG, \"onRequestPermissionResult\");\n            if (requestCode == REQUEST_PERMISSIONS_REQUEST_CODE) {\n                if (grantResults.length <= 0) {\n                    // If user interaction was interrupted, the permission request is cancelled and you\n                    // receive empty arrays.\n                    Log.i(TAG, \"User interaction was cancelled.\");\n                } else if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n                    // Permission granted.\n                    getLastLocation();\n                } else {\n                    // Permission denied.\n\n                    // Notify the user via a SnackBar that they have rejected a core permission for the\n                    // app, which makes the Activity useless. In a real app, core permissions would\n                    // typically be best requested during a welcome-screen flow.\n\n                    // Additionally, it is important to remember that a permission might have been\n                    // rejected without asking the user for permission (device policy or \"Never ask\n                    // again\" prompts). Therefore, a user interface affordance is typically implemented\n                    // when permissions are denied. Otherwise, your app could appear unresponsive to\n                    // touches or interactions which have required permissions.\n                    showSnackbar(R.string.permission_denied_explanation, R.string.settings,\n                            new View.OnClickListener() {\n                                @Override\n                                public void onClick(View view) {\n                                    // Build intent that displays the App settings screen.\n                                    Intent intent = new Intent();\n                                    intent.setAction(\n                                            Settings.ACTION_APPLICATION_DETAILS_SETTINGS);\n                                    Uri uri = Uri.fromParts(\"package\",\n                                            BuildConfig.APPLICATION_ID, null);\n                                    intent.setData(uri);\n                                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n                                    startActivity(intent);\n                                }\n                            });\n                }\n            }\n        }\n\n\n        /**\n         * Provides a simple way of getting a device's location and is well suited for\n         * applications that do not require a fine-grained location and that do not need location\n         * updates. Gets the best and most recent location currently available, which may be null\n         * in rare cases when a location is not available.\n         * <p>\n         * Note: this method should be called after location permission has been granted.\n         */\n        @SuppressWarnings(\"MissingPermission\")\n        private void getLastLocation() {\n            mFusedLocationClient.getLastLocation()\n                    .addOnCompleteListener(getActivity(), new OnCompleteListener<Location>() {\n                        @Override\n                        public void onComplete(@NonNull Task<Location> task) {\n                            if (task.isSuccessful() && task.getResult() != null) {\n                                lastLocation = task.getResult();\n\n                                txtLatitude.setText(String.valueOf(lastLocation.getLatitude()));\n                                txtLongitude.setText(String.valueOf(lastLocation.getLongitude()));\n\n                            } else {\n                                Log.w(TAG, \"getLastLocation:exception\", task.getException());\n                                showSnackbar(getString(R.string.no_location_detected));\n                            }\n                        }\n                    });\n        }\n\n        private void stopLocationUpdates() {\n            mFusedLocationClient.removeLocationUpdates(mLocationCallback);\n        }\n\n        private void startLocationUpdates() {\n            if (ActivityCompat.checkSelfPermission(getActivity(), Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(getActivity(), Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {\n                // TODO: Consider calling\n                //    ActivityCompat#requestPermissions\n                // here to request the missing permissions, and then overriding\n                //   public void onRequestPermissionsResult(int requestCode, String[] permissions,\n                //                                          int[] grantResults)\n                // to handle the case where the user grants the permission. See the documentation\n                // for ActivityCompat#requestPermissions for more details.\n                return;\n            }\n            mFusedLocationClient.requestLocationUpdates(locationRequest, mLocationCallback, null);\n        }\n\n        // private void showSnackbar(final String text) {\n        //    if (canvasLayout != null) {\n        //        Snackbar.make(canvasLayout, text, Snackbar.LENGTH_LONG).show();\n        //    }\n        //}\n        // this also cause wrong code and as I see it dont is necessary\n        // because the same method which is really used\n\n\n        private void showSnackbar(final int mainTextStringId, final int actionStringId,\n                                  View.OnClickListener listener) {\n            Snackbar.make(getActivity().findViewById(android.R.id.content),\n                    getString(mainTextStringId),\n                    Snackbar.LENGTH_INDEFINITE)\n                    .setAction(getString(actionStringId), listener).show();\n        }\n    }\n",
      "href": "java - Android LocationServices.FusedLocationApi deprecated - Stack Overflow"
    }
  ]
}